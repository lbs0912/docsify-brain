# 编程-01-面试好题汇总


[TOC]




## 参考资料
* [面试高频榜单 | 牛客网](https://www.nowcoder.com/exam/oj?page=1&pageSize=50&search=%E8%8D%92%E5%B2%9B&tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=117)
* [剑指 offer | 牛客网](https://www.nowcoder.com/exam/oj/ta?page=1&tpId=13&type=265&from=ad_baidu_sem_tiku_jianzhioffer&bd_vid=10426780312344788874)
* [华为机试 | 牛客网](https://www.nowcoder.com/exam/oj/ta?page=3&tpId=37&type=37)



## Java获取字符串的MD5值

* [Java获取字符串的MD5值 | CSDN](https://blog.csdn.net/yu540135101/article/details/86765457)



```java
package com.example.administrator.myapplication.StringUtils;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Encryption {
    private final static String[] hexArray = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};

    /***
     * 对指定的字符串进行MD5加密
     */
    public static String encrypByMD5(String originString) {
        try {
            //创建具有MD5算法的信息摘要
            MessageDigest md = MessageDigest.getInstance("MD5");
            //使用指定的字节数组对摘要进行最后更新，然后完成摘要计算
            byte[] bytes = md.digest(originString.getBytes());
            //将得到的字节数组变成字符串返回
            String s = byteArrayToHex(bytes);
            return s.toUpperCase();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return null;
    }
    /**
     * 将字节数组转换成十六进制，并以字符串的形式返回
     * 128位是指二进制位。二进制太长，所以一般都改写成16进制，
     * 每一位16进制数可以代替4位二进制数，所以128位二进制数写成16进制就变成了128/4=32位。
     */
    private static String byteArrayToHex(byte[] b){
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < b.length; i++) {
            sb.append(byteToHex(b[i]));
        }
        return sb.toString();
    }
    /**
     * 将一个字节转换成十六进制，并以字符串的形式返回
     */
    public static String byteToHex(byte b) {
        int n = b;
        if (n < 0)
            n = n + 256;
        int d1 = n / 16;
        int d2 = n % 16;
        return hexArray[d1]+hexArray[d2];
    }
}
```


## 数组中比左边元素都大同时比右边元素都小的元素


求数组中比左边元素都大同时比右边元素都小的元素，返回这些元素的索引

要求时间复杂度 `O(N)`。

```s
输入：[2, 3, 1, 8, 9, 20, 12]
输出：3, 4
解释：数组中 8, 9 满足题目要求，他们的索引分别是 3、4
```

通过分析可以得到，对于每个元素，如果它比左侧最大的值要大，同时比右侧最小的值要小，就满足条件。

那如果有这样两个数组
1. `left_max[i]` 表示原数组 `[0, i)` 的最大值
2. `right_min[i]` 表示原数组 `(i, n)` 的最小值

那么，就可以通过 `left_max[i] < nums[i] && nums[i] < right_min[i]` 来判断了。


代码实现如下。

```java
import java.util.ArrayList;
import java.util.List;

public class Solution {
    public static void main(String[] args) {
        int[] arr = {2, 3, 1, 8, 9, 20, 12};
        int[] res = new Solution().getIndex(arr);
        for(int i=0;i<res.length;i++){
            System.out.println(res[i]);
        }
    }

    private int[] getIndex(int[] arr) {
        int len = arr.length;
        int[] left_max = new int[len];
        int[] right_min = new int[len];

        for (int i = 1; i < len; i++) {
            left_max[i] = Math.max(left_max[i - 1], arr[i - 1]);
        }

        for (int i = len - 2; i >= 0; i--) {
            if(i == len -2){
                right_min[len-2] = arr[len-1];
            } else {
                right_min[i] = Math.min(right_min[i + 1], arr[i + 1]);
            }

        }
        List<Integer> list  = new ArrayList<>();
        for (int i = 0; i < len; i++) {
            if(left_max[i] < arr[i] && arr[i] < right_min[i]){
                list.add(i);
            }
        }
        return list.stream().mapToInt(Integer::valueOf).toArray();
    }

}
```




## JSON格式化
* ref 1-[JSON格式化和压缩成一行](https://www.programminghunter.com/article/97002266287/)



```java
    /**
     * 去除字符串中的空格、回车、换行符、制表符
     *     \n 回车(\u000a)
     *     \t 水平制表符(\u0009)
     *     \s 空格(\u0008)
     *     \r 换行(\u000d)
     * @param source
     * @return
     */
    public static String replaceBlank(String source) {
        String ret = EMPTY;
        if (StringUtils.isNotBlank(source)) {
            ret = source.replaceAll(StringUtils.LF, EMPTY)
                    .replaceAll("\\s{2,}",  EMPTY)
                    .replaceAll("\\t", EMPTY)
                    .replaceAll(StringUtils.CR,  EMPTY);
        }
        return ret;
    }
```


## Map数据结构设计

* ref 1-[数据结构设计 | CSDN](https://blog.csdn.net/u012248802/article/details/79753546)

题目要求如下
1. 设计一个 `set(index, value)`, `get(index)`,`setAll(value)` 都为 `O(1)` 的数据结构



题目思路如下
1. 每一个记录都加上一个时间，标记每条记录是何时建立的
2. 设置一个 setAll 记录也加上一个时间，标记 setAll 记录何时建立
3. 查询记录时，如果某条记录的时间小于 setAll 记录的时间，说明 setAll 是最新数据，返回 setAll 记录的值；如果某条记录的时间大于 setAll 记录的时间，说明记录的值是最新数据，返回该条记录的值。


代码实现如下。


```java
import java.util.HashMap;
 
class Value<T>{
    T value;
    int time;
    public Value(T value, int time){
        this.value = value;
        this.time = time;
    }
}
 
class MyMap<K, V> {
    HashMap<K,Value<V>> map = new HashMap<>();
    public int time = 0;//记录当前添加数据的时间戳
    public int setAllTime = -1;//记录setAll操作的时间戳
    V value = null;

    public void set(K key, V value){//添加数据
        Value<V> temp = new Value<>(value, time);
        map.put(key, temp);
        time++;
    }
 
    public void setAll(V value){//更新所有记录的值
        //setAll时更新的value 是被这个类锁持有的 全局唯一的
        this.value = value; 
        setAllTime = time;
        time++;
    }
 
    public V get(K key){
        if (map.containsKey(key)){
            if(map.get(key).time < setAllTime){
                return value;
            }else {
                return map.get(key).value;
            }
        }
        return null;
    }
}
```

## 华为机试-简易内存池
* [简易内存池的实现 | CSDN](https://blog.csdn.net/weixin_41563161/article/details/116518399)



```s
# 测试用例1

2
REQUEST=10
REQUEST=20
输出样例1
0
10

# 测试用例2
5
REQUEST=10
REQUEST=20
RELEASE=0
REQUEST=20
REQUEST=10
输出样例2
0
10
30
0
```


代码实现如下。


```java
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.TreeMap;
public class Solution {
    static class AllocatedMemory {
        // 记录已被分配的区间信息
        private TreeMap<Integer, Integer> hasAllocated; //记录每一段分配的起点和终点  如0-10,10-30
        // 内存池边界
        private int Address_DEFAULT_HEAD = 0;
        private int Address_DEFAULT_End = 100;
        AllocatedMemory() {
            hasAllocated = new TreeMap<>();
        }

        // 返回分配的内存首地址(string)，失败返回字符串 "error"
        String request(int size) {
            int addressHead = Address_DEFAULT_HEAD;
            // 校验
            if (size <= 0 || size > 100) {
                return "error";
            }
            if (hasAllocated.isEmpty()) {
                //如果为空就直接插入
                hasAllocated.put(Address_DEFAULT_HEAD, size);
            }else {
                List<Integer> headList = new ArrayList<>(hasAllocated.keySet());
                //取出所有的已申请内存首地址
                for (int i = 0; i < headList.size(); i++) {
                    // 需要分配的内存小于空余空间，直接分配
                    if (headList.get(i) - addressHead >= size) {
                        //从头开始遍历，看内存空间是否足够，足够就存入进去
                        hasAllocated.put(addressHead, addressHead + size);
                    }else {
                        addressHead = hasAllocated.get(headList.get(i));
                    }
                }
                if (size <= Address_DEFAULT_End - addressHead) {
                    //如果超出了怎么办
                    hasAllocated.put(addressHead, addressHead + size);
                }else{
                    return "error";
                }
            }
            return String.valueOf(addressHead);

        }

        // 成功返回 true；失败返回 false，失败时框架会自动输出 "error"
        boolean release(int startAddress) {
            if (hasAllocated.containsKey(startAddress)) {
                hasAllocated.remove(startAddress);
                return true;
            }
            return false;
        }
        /**
         * main入口由OJ平台调用
         */
        public static void main(String[] args) {
            Solution.AllocatedMemory allocatedMemory = new Solution.AllocatedMemory();
            Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
            int line = Integer.parseInt(cin.nextLine());
            String[][] ins = new String[line][2];
            for (int i = 0; i < line; i++) {
                ins[i] = cin.nextLine().split("=");
                if (ins[i][0].startsWith("REQUEST")) {
                    System.out.println(allocatedMemory.request(Integer.parseInt(ins[i][1])));
                } else {
                    boolean ret = allocatedMemory.release(Integer.parseInt(ins[i][1]));
                    if (!ret) {
                        System.out.println("error");
                    }
                }
            }

            cin.close();
        }
    }
}

```


## 最长公共子序列的长度

### 动态规划

* [LeetCode-1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)


动态规划求解，`dp[i][j]` 表示第一个字符串到第 `i` 位，第二个字符串到第 `j` 位为止的最长公共子序列长度，则有状态转移方程
1. 若 `s1.charAt(i - 1) == s2.charAt(j - 1)`，则 ` dp[i][j] = dp[i - 1][j - 1] + 1`
2. 否则，`dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])`




```java
class Solution {
    public int longestCommonSubsequence(String s1, String s2) {
        if(s1.length() == 0 || s2.length() == 0){
            return 0;
        }

        int len1 = s1.length();
        int len2 = s2.length();
        //dp[i][j]表示第一个字符串到第i位，第二个字符串到第j位为止的最长公共子序列长度
        int[][] dp = new int[len1+1][len2+1]; 

        for(int i = 1; i <= len1; i++){
            for(int j = 1; j <= len2; j++){
                if(s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }  
            }
        }
        return dp[len1][len2];
    }
}
```



## 最长公共子串

* [HJ65 查找两个字符串a,b中的最长公共子串 | 华为机试](https://www.nowcoder.com/practice/181a1a71c7574266ad07f9739f791506?tpId=37&tqId=21288&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D2%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)



### 动态规划

动态规划求解，`dp[i][j]` 表示第一个字符串到第 `i` 位，第二个字符串到第 `j` 位为止的最长公共子串，则有状态转移方程
1. 若 `s1.charAt(i - 1) == s2.charAt(j - 1)`，则 ` dp[i][j] = dp[i - 1][j - 1] + 1`
2. 否则，`dp[i][j] = 0`（注意，这点和求解最长公共子序列的状态转移方程不同）



> 注意，因为要计算 `dp[i - 1][j - 1]`，所以为了方便，创建数组的长度为 `len + 1`。



```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner sc=new Scanner(System.in);
        while(sc.hasNext()){
            String s1=sc.nextLine();
            String s2=sc.nextLine();
            System.out.println(longString(s1,s2));
        }
    }
    
    // 动态规划
    public static String longString(String str1, String str2) {
        String temp = "";
        // 保证str1是较短字符串
        if (str1.length() > str2.length()) {
            temp = str1;
            str1 = str2;
            str2 = temp;
        }
        int m = str1.length() + 1;
        int n = str2.length() + 1;
        // 表示在较短字符串str1以第i个字符结尾，str2中以第j个字符结尾时的公共子串长度。
        int[][] dp = new int[m][n];
        // 匹配字符，并记录最大值的str1的结尾下标
        int max = 0;
        int index = 0;
        // 从左向右递推，i为短字符串str1的结尾索引，j为str2的结尾索引
        for (int i=1; i < m; i++) {
            for (int j=1; j < n; j++) {
                if (str1.charAt(i-1) == str2.charAt(j-1)) {
                    // 相等则计数
                    dp[i][j] = dp[i-1][j-1] + 1;
                    // 不断更新变量
                    if (dp[i][j] > max) {
                        max = dp[i][j];
                        index = i;
                    }
                }
            }
        }
        // 截取最大公共子串
        return str1.substring(index-max, index);
    }
}

```



## 华为-字符串排序

### 题目描述

* 输入一个字符串，对英文字母按照 ASCII 码排序，非英文字母保留原有的位置。输入字符串长度不超过100。
* 输入: 字符串
* 输出: 排序后的字符串
* 样例输入: Wor#d
* 样例输出: Wdo#r

### 计数排序

1. 创建两个数组，分别对大写字母和小写字母出现的频率进行统计
2. 再遍历一次数组，根据大小写字母出现的频率，插入到结果数组中，实现计数排序



```java

import java.util.*;

public class Main {
    public static void main(String args[]) {
        Scanner cin = new Scanner(System.in);
        while (cin.hasNext()) {
            String str = cin.next();
            System.out.println(getAlphabetOrderString(str));
        }
    }

    public static String getAlphabetOrderString(String str) {
        if (str == null || str.length() == 0) {
            return "";
        }
        char[] charArr = str.toCharArray();
        int[] upperCaseFrequency = new int[26]; //记录大写字母出现频率
        int[] lowerCaseFrequency = new int[26]; //记录小写字母出现频率
        for(char c:charArr){
            if(!Character.isAlphabetic(c)){
                continue;
            }
            if(c >= 'a') { // 97
                lowerCaseFrequency[c - 'a']++;
            } else {
                upperCaseFrequency[c - 'A']++;
            }
        }
        int index = 0;
        //大写字母插入
        for(int i=0;i<upperCaseFrequency.length;i++){
            if(upperCaseFrequency[i] > 0){
                int count = upperCaseFrequency[i];
                char c = (char)(i + 'A');
                while(count > 0 && index < charArr.length){
                    if(Character.isAlphabetic(charArr[index])){
                        charArr[index] = c;
                        index++;
                        count--;
                    } else {
                        index++;
                    }
                }

            }
        }
        //小写字母插入
        for(int i=0;i<lowerCaseFrequency.length;i++){
            if(lowerCaseFrequency[i] > 0){
                int count = lowerCaseFrequency[i];
                char c = (char)(i + 'a');
                while(count > 0 && index < charArr.length){
                    if(Character.isAlphabetic(charArr[index])){
                        charArr[index] = c;
                        index++;
                        count--;
                    } else {
                        index++;
                    }
                }

            }
        }
        return String.valueOf(charArr);
    }
}
```


## 华为-单词倒排

* [HJ31 单词倒排 | 华为机试](https://www.nowcoder.com/practice/81544a4989df4109b33c2d65037c5836?tpId=37&tqId=38366&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)




### 正则匹配

* [正则表达式介绍 | 牛客网](https://www.nowcoder.com/questionTerminal/c2c5adc8dc29418980197db766c63381)
* [正则表达 | 菜鸟教程](https://www.runoob.com/regexp/regexp-tutorial.html)




|  元字符   |       描述       |
|----------|------------------|
| `\`   | 转义字符，如若要匹配 `.`，则需转义，使用 `\.`。对于 Java 的 String 的 `split()` 方法，转义格式为 `split("\\.")` |
| `^` | 匹配输入字符串的开始位置 |
| `$` |  匹配输入字符串的结束位置 |
| `*` | 匹配前面的子表达式任意次（包括 0 次）。例如，`zo*` 能匹配 `z`，也能匹配`zo`、`zoo`。`zo*` 等价于 `zo{0,}` |
| `+` | 匹配前面的子表达式一次或多次( >= 1）。例如，`zo+` 能匹配 `zo` 以及 `zoo`，但不能匹配 `z`。`zo+` 等价于 `zo{1,}` |
| `?` | 匹配前面的子表达式零次或一次。例如，`do(es)?` 可以匹配 `do` 或 `does`。 `?` 等价于 `{0,1}` |
| `{n}` | 匹配确定的 n 次。例如， `o{2}` 不能匹配 `Bob` 中的 `o`，但是可以匹配 `food` 中的 `oo` |
| `{n,}` | 至少匹配 n 次。例如，`o{2,}` 不能匹配 `Bob` 中的 `o`，但能匹配 `foooood` 中的所有 `o`。`o{1,}` 等价于 `o+`，`o{0,}` 则等价于 `o*` |
| `{n,m}` | 最少匹配 n 次且最多匹配 m 次 |
| `x|y` | 匹配 x 或 y。例如，`z|food` 能匹配 `z` 或 `food` |
| `[xyz]` | 字符集合，匹配所包含的任意一个字符。例如，`[abc]` 可以匹配 `plain` 中的 `a` |
| `[^xyz]` | 负值字符集合，匹配未包含的任意字符。例如，`[^abc]` 可以匹配 `plain`中的 `plin` |
| `[a-z]` | 字符范围，匹配指定范围内的任意字符。例如，`[a-z]` 可以匹配任意小写字母字符 |
| `[^a-z]` |负值字符范围，匹配任何不在指定范围内的任意字符。例如，`[^a-z]` 可以匹配任何非小写字母字符 |
| `\b` | 匹配一个单词边界，也就是指单词和空格间的位置。例如，`er\b` 可以匹配 `never` 中的 `er`，但不能匹配 `verb` 中的 `er` |
| `\B` | 匹配非单词边界。`er\B` 能匹配 `verb` 中的 `er`，但不能匹配 `never` 中的`er` |
| `\d` | 匹配一个数字字符，等价于 `[0-9]` |
| `\D` | 匹配一个非数字字符，等价于 `[^0-9]` |
| `\f` | 匹配一个换页符，等价于 `\x0c` 和 `\cL` |
| `\n` | 匹配一个换行符，等价于 `\x0a` 和 `\cJ` |
| `\r` | 匹配一个回车符，等价于 `\x0d` 和 `\cM` |
| `\s` | 匹配任何不可见字符，包括空格、制表符、换页符等等 |
| `\S` | 匹配任何可见字符
| `\t` | 匹配一个制表符
| `\w` | 匹配包括下划线的任何单词字符。类似但不等价于 `[A-Za-z0-9_]`，这里的「单词」字符使用 Unicode 字符集 |
| `\W` | 匹配任何非单词字符。等价于 `[^A-Za-z0-9_]`。|



如上表所示，此处进行必要的补充说明
1. 字母大写表示「非」。
   * `d` 表示 `digit`，匹配一个数字字符就是 `\d`，等价于 `[0-9]`；匹配一个非数字字符就是 `\D`，等价于 `[^0-9]`
   * `w` 表示 `word`，匹配包括下划线的任何单词字符就是 `\W`，匹配任何非单词字符就是 `\W`
2. `[]` 中用 `^` 表示「非」
   * `[0-9]` 表示任意数字字符，`[^0-9]` 表示任意非数字字符
   * `[a-z]` 表示匹配任意小写字母，`[^a-z]` 表示匹配任意非小写字母



> 注意 `^` 符号的位置
> 1. `[^a-z]` 中的 `^` 在 `[]` 内部，表示「非」，匹配任意非小写字母
> 2. `^[a-z]` 中的 `^` 在 `[]` 外部，匹配以任意小写字母开头的字符串

### 代码实现

`str.split("[^a-zA-Z]")` 表示匹配非字母，本题使用 `str.split("\\W")` 也可以执行通过。



```java
import java.util.Scanner;

public class Main{
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String str = scanner.nextLine();
        String[] splitStr = str.split("[^a-zA-Z]"); //非字母都用作分隔符
        StringBuilder sb = new StringBuilder();
        for (int i = splitStr.length - 1; i >= 0; i--) {
            sb.append(splitStr[i]);
            if(i != 0) {
                sb.append(" ");
            }
        }
        System.out.println(sb.toString());
    }
}
```


### 题目引申

* [HJ40 统计字符 | 华为机试](https://www.nowcoder.com/practice/539054b4c33b4776bc350155f7abd8f5?tpId=37&tqId=21263&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)


```java
import java.util.Scanner;

public class Main{

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Scanner in=new Scanner(System.in);
        while(in.hasNext()){
            String str=in.nextLine();
            String s1=str.replaceAll("[A-Z]+|[a-z]+", ""); //+表示匹配一次或多次
            System.out.println(str.length()-s1.length());
            String s2=s1.replaceAll(" ", "");
            System.out.println(s1.length()-s2.length());
            String s3=s2.replaceAll("[0-9]+", "");
            System.out.println(s2.length()-s3.length()+"\n"+s3.length());
        }
    }

}
```




## 华为-表示数字


* [HJ96 表示数字 | 牛客网](https://www.nowcoder.com/practice/637062df51674de8ba464e792d1a0ac6?tpId=37&tqId=21319&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3FjudgeStatus%3D3%26page%3D2%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=3&tags=&title=)



### 遍历匹配

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            String str = in.next();
            boolean numberBegin = false;
            StringBuilder sb = new StringBuilder();
            
            for(int i=0;i< str.length();i++){
                char c = str.charAt(i);
                if(Character.isDigit(c)){
                    if(!numberBegin){
                        sb.append("*"); 
                        numberBegin = true;
                    } 
                    sb.append(c);
                    if(i == str.length() - 1){
                        //最后一个字符为数字
                         sb.append("*"); 
                    }
                } else {
                    if(numberBegin){
                        sb.append("*");
                        numberBegin = false;
                    }
                    sb.append(c);
                }
            }
            System.out.println(sb.toString());
        }
    }
    
}
```


### 正则匹配


正则表达式中，使用 `$1` 表示前面第一个正则表达式匹配到的内容。



```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String input = scanner.next();
            System.out.println(input.replaceAll("([0-9]+)", "*$1*")); //把所有的数字段提取出来，前后加上星号再放回去
        }
    }
}
```



## 华为-删除字符串中出现次数最少的字符
* [HJ23 删除字符串中出现次数最少的字符 | 华为机试](https://www.nowcoder.com/practice/05182d328eb848dda7fdd5e029a56da9?tpId=37&tqId=21246&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)



### Map的使用


下面两种写法等价。

```java
int min = Integer.MAX_VALUE;
for (int times : map.values()) {
    min = Math.min(min, times);
}
```

```java
int min = Integer.MAX_VALUE;
for(Map.Entry<Character,Integer> entry:map.entrySet()){
    min = Math.min(min,entry.getValue());
}
```


### 代码实现

```java

import java.util.*;

public class Main {

   public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNextLine()) {
            String str = in.nextLine();
            String res = delete(str);
            System.out.println(res);
        }
    } 

    public static String delete(String str) {
        // Map记录每个字母的次数
        Map<Character, Integer> map = new HashMap<>();
        for (char ch : str.toCharArray()) {
            map.put(ch, map.getOrDefault(ch, 0) + 1);
        }
        // 快速找出最少次数
        int min = Integer.MAX_VALUE;
//         for (int times : map.values()) {
//             min = Math.min(min, times);
//         }
        for(Map.Entry<Character,Integer> entry:map.entrySet()){
            min = Math.min(min,entry.getValue());
        }
        
        
        
        StringBuilder res = new StringBuilder();
        for (char ch : str.toCharArray()) {
            if (map.get(ch) != min) {
                res.append(ch);
            }
        }
        return res.toString();
    }

    
}
```


## 斐波那契额数列

### 兔子出生
* [HJ37 统计每个月兔子的总数](https://www.nowcoder.com/practice/1221ec77125d4370833fd3ad5ba72395?tpId=37&tqId=21260&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)


设第 n 个月的兔子数量为 `num[n]`，第 n 个月的兔子，来源有两部分
1. 第 n-1 个月已有的兔子，即 `num[n-1]`
2. 新出生的兔子，即 `num[n-2]` 

因此有，`num[n] = num[n-1] + num[n-2]`，即斐波那契数列问题。

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()){
            int n = sc.nextInt();
            System.out.println(dp(n));
        }
    }
    public static int dp(int n){
        int num[] = new int[n+1];
        num[1] = 1;
        num[2] = 1;
        for(int i=3;i<=n;i++){
            num[i] = num[i-1] + num[i-2];
        }
        return  num[n];
    }
}
```



## 青蛙跳石板

### 斐波那契额数列
* [LeetCode-剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)


一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。


设跳上 n 级台阶有 `f(n)` 种跳法。在所有跳法中，青蛙的最后一步只有两种情况，跳上 1 级或 2 级台阶
1. 若最后一步为跳 1 级台阶，则有 `f(n) = f(n-1)`
2. 若最后一步为跳 2 级台阶，则有 `f(n) = f(n-2)`
3. 故，总的跳法为 `f(n) = f(n-1) + f(n-2)`


这正是斐波那契额数列的应用。

```s
            | 1, (n=0，0级台阶认为跳法1)   
    f(n) =  | 1, (n=1)
            | 2, (n=2) 
            | f(n-1)+f(n-2)  (n>1)
```


代码实现如下。

```java
class Solution {
    public int numWays(int n) {
        if(n == 0) return 1;
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i < n + 1; i++){
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        }
        return dp[n];
    }
}
```

由于最终结果只和 `f(n-2)`、 `f(n-1)` 有关，故可以使用三个变量保存结果，节省存储空间。


```java
class Solution {
    public int numWays(int n) {
        int a = 1, b = 1, sum;
        for(int i = 0; i < n; i++){
            sum = (a + b) % 1000000007;
            a = b;
            b = sum;
        }
        return a;
    }
}
```

### 数学推导

如果青蛙可以一次跳 1 级，也可以一次跳 2 级，一次跳 3 级，…，一次跳 n 级，要跳上第 n 级台阶有多少种跳法。

设跳上 n 级台阶有 `f(n)` 种跳法，有如下计算过程

```s
f(n) = f(n−1) + f(n−2) + ... + f(1)
f(n−1) = f(n−2) + f(n−3) + ... + f(1)

-> f(n) = 2 * f(n-1) = 4 * f(n-2) = ... = 2^(n-1)
```

可以发现，最终答案为 `f(n) = 2^(n-1)`。


### 动态规划
* [跳石板 | 牛客网](https://www.nowcoder.com/questionTerminal/4284c8f466814870bae7799a07d49ec8)


使用动态规划求解，有如下转移方程。

```s
dp[i+factor] = Math.min(dp[i]+1,dp[i+factor]);
```

代码实现如下。



```java
import java.util.Scanner;


public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int N = in.nextInt();
        int M = in.nextInt();
        int[] dp = new int[M+1];
  
        //初始化 不可到达
        for(int i=0;i<M+1;i++){
            dp[i] = Integer.MAX_VALUE;
        }      
        //目前已经处于编号N的石板
        dp[N] = 0; 
        
        for(int i=N;i<M+1;i++){
            if(dp[i] == Integer.MAX_VALUE){
                continue;
            }
            //因子
            for(int j=2;(j*j) <= i;j++){
                if(i%j == 0){
                    int factor1 = j;
                    int factor2 = i/j;
                    
                    if(factor1 + i <= M){
                        dp[i+factor1] = Math.min(dp[i]+1,dp[i+factor1]);
                    }
                    //factor1 != factor2  注意不等的判断
                    if(factor1 != factor2 && factor2 + i <= M){
                        dp[i+factor2] = Math.min(dp[i]+1,dp[i+factor2]);
                    }
                }
            }
        } 
        if(dp[M] == Integer.MAX_VALUE){
            dp[M] = -1;
        }  
        
        System.out.println(dp[M]);
        
    }
}
```


## 华为-字符串自定义排序

* [HJ26 字符串排序 | 牛客](https://www.nowcoder.com/practice/5190a1db6f4f4ddb92fd9c365c944584?tpId=37&tqId=21249&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)
  


排序规则
1. 英文字母从 A 到 Z 排列，不区分大小写。
2. 同一个英文字母的大小写同时存在时，按照输入顺序排列。
3. 非英文字母的其它字符保持原来的位置。


```s
# 规则1
输入： Type 输出： epTy
# 规则2
输入： BabA 输出： aABb
# 规则3
输入： By?e 输出： Be?y
```


### 自定义排序

1. 使用一个数组记录字符串中出现的字母
2. 对数组自定义排序，实现如下

```java
// 将英文字母先排序好
letters.sort(new Comparator<Character>() {
    public int compare(Character o1, Character o2) {
        //按照它们的小写字母进行排序
        //对于同一个字母的大写和小写，比较结果为0，则不进行位置更换，这样可以满足规则 2
        return Character.toLowerCase(o1) - Character.toLowerCase(o2);
    }
});
```

3. 最后对结果进行拼装



最后给出代码实现。

```java
import java.util.*;

public class Main {

    public static String sort(String str) {
        // 先将英文字母收集起来
        List<Character> letters = new ArrayList<>();
        for (char ch : str.toCharArray()) {
            if (Character.isLetter(ch)) {
                letters.add(ch);
            }
        }
        // 将英文字母先排序好
        letters.sort(new Comparator<Character>() {
            public int compare(Character o1, Character o2) {
                return Character.toLowerCase(o1) - Character.toLowerCase(o2);
            }
        });
        // 若是非英文字母则直接添加
        StringBuilder result = new StringBuilder();
        for (int i = 0, j = 0; i < str.length(); i++) {
            if (Character.isLetter(str.charAt(i))) {
                result.append(letters.get(j++));
            }
            else {
                result.append(str.charAt(i));
            }
        }
        return result.toString();
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNextLine()) {
            String str = in.nextLine();
            String res = sort(str);
            System.out.println(res);
        }
    } 
}
```

## 华为-字符串排序

* [HJ14 字符串排序 | 华为机试](https://www.nowcoder.com/practice/5af18ba2eb45443aa91a11e848aa6723?tpId=37&tqId=21237&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)



调用 `list.sort()`，并自定义排序。


注意在接受时，使用 `next()`，不要使用 `nextLine()`（会带有字符串前后的空格）。


```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int len = in.nextInt();
        List<String> list = new ArrayList<>(len);
        for (int i = 0; i < len; i++) {
            list.add(in.next());  //不要使用nextLine() 否则会带有空格
        }


        list.sort(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                int len1 = o1.length();
                int len2 = o2.length();
                int index = 0;
                while (index < len1 && index < len2) {
                    if (o1.charAt(index) != o2.charAt(index)) {
                        return (o1.charAt(index) > o2.charAt(index))? 1:-1;
                    } 
                    index++;
                }
                //相等的时候返回0 表示不交换
                if(len1 == len2){
                    return 0;
                } else {
                    return (len1 > len2)? 1:-1;
                }
                
            }
        });
        for (int i = 0; i < len; i++) {
            System.out.println(list.get(i));
        }

    }

}
```


## 称砝码（好题）

* [HJ41 称砝码 | 牛客网](https://www.nowcoder.com/practice/f9a4c19050fc477e9e27eb75f3bfd49c?tpId=37&tqId=21264&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)




### Set去重

1. 首先根据输入顺序，将砝码用数字序列表示，例如 2个 1g 和 1个 2g，就用 `1 1 2` 的序列表示
2. 使用 Set 表示加入当前砝码之前能产生的重量种类
3. set 初始化为 `{0}`；
4. 当第一个 1g 砝码放入时，则 set 中需要插入原先 set 中的所有元素 +1g后的结果，即 `{0, 0+1}`
5. 当第二个 1g 加入时，则 set 会插入 `{0+1, 1+1}`，所以 set 最终变为`{0, 1, 2}`
6. 重复上述步骤加入所有砝码
7. 最后 set 的大小即为能产生的重量种类



```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            int n = in.nextInt();
            int[] weightArr = new int[n];
            int[] countArr = new int[n];
          
            for(int i=0;i<n;i++){
                weightArr[i] = in.nextInt();
            }
            for(int i=0;i<n;i++){
                countArr[i] = in.nextInt();
            }
            
            List<Integer> list = new ArrayList<Integer>();
            for(int i=0;i<n;i++){
                int weight = weightArr[i];
                int count = countArr[i];
                while(count > 0){
                    list.add(weight);
                    count--;
                }
            }
               
            Set<Integer> set = new HashSet<>();
            set.add(0);
            for(int i=0;i<list.size();i++){
             
//                 for(Integer val:set){
//                     int newVal = val + list.get(i);
//                     set.add(newVal);
//                 }
                //注意 
                //这里不要在遍历过程中向set插入异常
                //否则会有 ConcurrentModificationException 异常
                List<Integer> tempList = new ArrayList<Integer>();
                
                for(Integer val:set){
                    tempList.add(val + list.get(i));
                }
                
                for(Integer weight: tempList){
                    set.add(weight);
                }
                tempList.clear();
            }
            System.out.println(set.size());
        }
        
    }
}

```


### 动态规划


```s
# 输入
3
10 20 15
2 2 3

# 输出
20
```

使用动态规划求解。结合上面测试用例，对求解步骤进行说明

1. 将所有砝码插入到一个数组 `list` 中，如 `[10,10,20,20,15,15,15]`
2. 记砝码总重量为 `weightSum`
3. 创建二维数组 `dp[list.size()+1][weightSum+1]`，其中 `dp[i][j]` 表示使用前 `i` 个砝码，是否可以称出重量 `j`
4. 边界条件
   * `dp[i][0] = true;`，表示对所有的砝码都不适用，肯定是能称出重量 0
   * `dp[0][j] = true; (j != 0)`，表示若不使用砝码，肯定不能称出大于 0 的重量
5. 动态转移方程为 `dp[i][j] = dp[i][j] || dp[i-1][j-weight] || dp[i-1][j]`，推导过程如下

```s
a. 记第 i 个砝码的重量为 weight = list.get(i)
b. 若 dp[i-1][j-weight] 为 true，则可通过使用第 i 个砝码，使 dp[i][j] 为 true
c. 若 dp[i-1][j] 为 true，则不使用第 i 个砝码，也可以使 dp[i][j] 为 true
```

6. 在动态规划过程中，使用一个 Set 结构记录称出的重量，即若 `dp[i][j] == true`，将重量 `j` 放入到 Set 中
7. 最后，计算出 Set 中元素的个数，就是称出的重量的种类


代码实现如下。


```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            int n = in.nextInt();
            int[] weightArr = new int[n];
            int[] countArr = new int[n];

            for(int i=0;i<n;i++){
                weightArr[i] = in.nextInt();
            }
            for(int i=0;i<n;i++){
                countArr[i] = in.nextInt();
            }

            //总总量
            int weightSum = 0;
            List<Integer> list = new ArrayList<Integer>();
            for(int i=0;i<n;i++){
                int weight = weightArr[i];
                int count = countArr[i];
                while(count > 0){
                    list.add(weight);
                    weightSum += weight;
                    count--;
                }
            }

            //dp[i][j] 表示用list中前i个砝码，是否可以称出重量j
            boolean[][] dp = new boolean[list.size() + 1][weightSum+1];
            //边界条件 1
            for(int i=0;i<=list.size();i++){
                dp[i][0] = true;
            }
            //边界条件 2  dp[0][j] = false;   dp[0][0] = true

            //set 去重记录重量
            Set<Integer> set = new HashSet<>();
            set.add(0);

            for(int i=1;i<=list.size();i++){
                int weight = list.get(i-1);
                for(int j=0;j<=weightSum;j++){
                    if(j - weight >=0){
//                         dp[i][j] = dp[i][j] || dp[i-1][j-weight] || dp[i-1][j];
                          dp[i][j] = dp[i][j] || dp[i-1][j-weight];
                        
                    }
                    dp[i][j] = dp[i][j] || dp[i-1][j];
                    
                    if(dp[i][j]){
                        set.add(j);
                    }
                }
            }

            System.out.println(set.size());
        }

    }
}
```


此处有一个容易出错的点，因为动态转移方程为 `dp[i][j] = dp[i][j] || dp[i-1][j-weight] || dp[i-1][j]`，所以直接采用如下代码实现。

```java
if(j - weight >=0){
    dp[i][j] = dp[i][j] || dp[i-1][j-weight] || dp[i-1][j];
}                
```


这种代码实现时错误的，因为 `j - weight >=0` 条件只针对 `dp[i-1][j-weight]`，对 `dp[i-1][j]` 并无此条件限制。正确的代码实现如下。


```java
if(j - weight >=0){
    dp[i][j] = dp[i][j] || dp[i-1][j-weight];
} 
dp[i][j] = dp[i][j] || dp[i-1][j];
```


## 华为-称苹果（好题）

* [HJ61 放苹果 | 华为机试](https://www.nowcoder.com/practice/bfd8234bb5e84be0b493656e390bdebf?tpId=37&tqId=21284&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D2%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)



### 动态规划


使用动态规划思想求解，记 `dp[i][j]` 表示使用 `i` 个苹果放入到 `j` 个盘子的方案数。
1. 若 `i<j`，即苹果比盘子数小
   * 比如将 2 个苹果放入 3 个盘子，必然会有一个盘子为空，即`{0,x,y}`，其中一位固定为 0，不会影响最终的方案数，这和将 2 个苹果放入 2 个盘子的方案数目是一样的，即 `{x,y}`
   * 因此有当 `i<j` 时，`dp[i][j] = dp[i][i]`
2. 若 `i>=j`，即苹果数目不小于盘子数时，考虑是否允许有空盘子（比如将 4 个苹果放入 3 个盘子）
   * 若允许有空盘，相当于盘子数量少一个（因为固定认为是空盘，不会影响最终方案数目），即 `{x,y,0}`，这对应着 `dp[i][j-1]`
   * 若不允许有空盘，对于 `j` 个盘子，相当于拿出来 `j` 个苹果，分配到每个盘子中，保证每个盘子分配到一个苹果，这对应着 `dp[i−j][j]`
   * 因此有当 `i>=j` 时，`dp[i][j] = dp[i][j-1] + dp[i−j][j]`
3. 边界条件
   * 对于只有 1 个盘子的情况，分配方案只有 1 种，`dp[i][1] = 1;`
   * 对于只有 0 个苹果的情况，分配方案只有 1 种，`dp[0][j] = 1;`
   * 对于只有 1 个苹果的情况，分配方案只有 1 种，`dp[1][j] = 1;`

```java
import java.util.Scanner;

public class Main{

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            int apple = in.nextInt();
            int dish = in.nextInt();
            

            if(apple == 0 || apple == 1 || dish == 1){
                System.out.println(1);
                return;    
            }

            int[][] dp = new int[apple+1][dish+1];
            
            // 边界条件
            // 1. dp[0][j] = 0;
            // 2. dp[i][0] = 0;
            // 3. dp[i][1] = 1;   只有一个盘子，分配方案只有1种
            for(int i=0;i<=apple;i++){
                dp[i][1] = 1;
            }
            for(int j=0;j<=dish;j++){
                dp[0][j] = 1;
                dp[1][j] = 1;
            }
            
            for(int i=2;i<=apple;i++){
                 for(int j=2;j<=dish;j++){
                     if(i < j){
                         //苹果比盘子数小
                         //比如将2个苹果放入3个盘子，必然会有一个盘子为空，即 {0,x,y}，即其中一位固定为0，不会影响最终的方案数
                         //这和将2个苹果放入2个盘子的方案数目是一样的，即 {x,y}
                         dp[i][j] = dp[i][i];
                     } else {
                         //苹果数目 >= 盘子数, 考虑是否每个盘子都要装苹果
                         //比如将4个苹果放入3个盘子，即 {x,y,z} -> dp[i][j]
                         //如果不装满所有的盘子，相当于盘子数量少一个，即 {x,y,0} -> dp[i][j-1]
                         //如果装满所有的盘子，则所有盘子里面至少有一个苹果，相当于所有盘子里面都去掉一个苹果再进行分配 -> dp[i−j][j]
                         dp[i][j] = dp[i][j-1];
                         if(i-j >= 0){
                              dp[i][j] += dp[i-j][j]; 
                         }
                     }
                 }
            }
            
           System.out.println(dp[apple][dish]);
        }
    }
}
```



## 华为-密码截取（回文串）

* [华为-密码截取（回文串） | 牛客网](https://www.nowcoder.com/practice/3cd4621963e8454594f00199f4536bb1?tpId=37&tqId=21255&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3FjudgeStatus%3D3%26page%3D1%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=3&tags=&title=)


采用动态规划思想求解，记 `d[i][j]` 表示索引区间 `[i,j]` 的字符串是否可以构成回文串
1. 若 `i=j`，则一定有 `dp[i][j] = true`
2. 若 `s[i] = s[j]` 并且 `(i+1) <= (j-1)`，则有 `dp[i][j] = dp[i+1][j-1]`。**该状态转移方程中，`i` 逐渐变大，`j` 逐渐变小，所以在循环过程中，要「反向迭代 `i`，正向迭代 `j`」，即保证计算 `dp[i][j]` 状态时，`dp[i+1][j-1]` 已经计算出来了。**
3. 若 `s[i] = s[j]` 但不满足 `(i+1) <= (j-1)`时，即 `i < j <= i+2`，这可以分为两种情况
   * `j=i+1`，此时 `s[i] = s[j]`，字符串为 AA，所以一定有 `dp[i][j] = true`
   * `j=i+2`，此时 `s[i] = s[j]`，字符串为 AXA，所以一定有 `dp[i][j] = true`
4. 边界条件为 `dp[i][i] = true`



### 动态规划




```java
import java.util.Scanner;

public class Main{

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            String str = in.next();
            int len = str.length();
            if(len == 1){
                System.out.println(1);
                return;
            }
            
            boolean[][] dp = new boolean[len][len];
            //边界条件
            for(int i=0;i<len;i++){
                dp[i][i] = true;
            }
            int maxLength = 1; //初始值是1 不是0
            //正向迭代j  反向迭代i
            for(int i=len-1;i>=0;i--){
                for(int j=i;j<len;j++){ //注意从j=i开始循环
                    if(i == j){   //line 1
                        dp[i][j] = true;
                    } else if(str.charAt(i) ==  str.charAt(j)){
                        if((i+1) <= (j-1)){
                            dp[i][j] = dp[i+1][j-1];
                        } else {
                           //(i+1) >= (j-1)
                           //再根据循环条件知道一定有 j>i (j=i的情况，已经在line 1 处排除)
                           //故有 i < j <= i+2，此时 j 一共有两种取值
                           // 1. j=i+1，此时s[i] = s[j]，字符串为AA，所以一定有  dp[i][j] = true;
                           // 2. j=i+2，此时s[i] = s[j]，字符串为AXA，所以一定有  dp[i][j] = true;
                           dp[i][j] = true;
                        
                        }
                    }
                    //更新最大长度
                    if(dp[i][j]){
                        maxLength = Math.max(maxLength,j-i+1);
                    }
                }
            }
            
            System.out.println(maxLength);
            
        }
        in.close();
    }
}
```

在这里记录一个编写代码时遇到的低级错误，错误版本如下。


```java
//条件1 (i+1) <= (j-1)
//条件2 dp[i+1][j-1]
if((i+1) <= (j-1) && dp[i+1][j-1]){
    dp[i][j] = true;  //line A
} else {
    dp[i][j] = true; //line B
}
```

上述版本是错误逻辑，该错误版本中，当条件 1 和条件 2，同时满足时，执行 `line A`。若不同时满足，执行 `line B`。

正确的逻辑时若满足条件 1，但不满足 条件 2 时，不应该执行 `line B`。 正确的版本如下。


```java
//条件1 (i+1) <= (j-1)

if((i+1) <= (j-1)){
    dp[i][j] = dp[i+1][j-1];  //line A
} else {
    dp[i][j] = true; //line B
}
```



## TreeSet和TreeMap

* TreeMap 是一个有序的 key-value 集合,基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序（从小到大）进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。
* TreeSet 是基于 TreeMap 实现的。TreeSet 中的元素支持 2 种排序方式：自然排序或者根据创建 TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。
* TreeSet 和 TreeMap 都是基于红黑树，其基本操作（add、remove 和 contains等）都是 `O(logn)` 的时间复杂度。
  
  



### TreeSet和数组合并

* [HJ80 整型数组合并 | 华为机试](https://www.nowcoder.com/practice/c4f11ea2c886429faf91decfaf6a310b?tpId=37&tqId=21303&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3FjudgeStatus%3D3%26page%3D1%26pageSize%3D50%26search%3D%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=3&tags=&title=)



使用 TreeSet 求解。


```java
import java.util.Scanner;
import java.util.TreeSet;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner((System.in));
        while (in.hasNext()) {
            int n1 = in.nextInt();
            int arr1[] = new int[n1];
            in.nextLine();
            for (int i = 0; i < n1; i++)
                arr1[i] = in.nextInt();
            in.nextLine();
            int n2 = in.nextInt();
            int arr2[] = new int[n2];
            for (int i = 0; i < n2; i++)
                arr2[i] = in.nextInt();
            TreeSet<Integer> ts = new TreeSet<>();
            for (int i : arr1)
                ts.add(i);
            for (int i : arr2)
                ts.add(i);
            for (int i : ts) {
                System.out.print(i);
            }
            System.out.println();
        }
    }
}
```