# 架构-01-架构设计概览



[TOC]


## 更新
* 2022/05/08，撰写




## 参考资料
* [架构设计面试精讲 | learn.lianglianglee.com](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2)


## 职业发展路线

![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/java-2020/coder-dev-path-1.png)






## 架构经典设计案例
### 《凤凰架构》周志明
* [凤凰架构](https://icyfenix.cn/)




### 《数据密集型应用系统设计》
* [《数据密集型应用系统设计》 | 在线阅读 gitbook](https://vonng.gitbooks.io/ddia-cn/content/)
* [《数据密集型应用系统设计》 | 阅读笔记](https://www.yuque.com/fuxuemingzhu/cdpqne)
* [《数据密集型应用系统设计》 介绍](https://mp.weixin.qq.com/s/kZMVTvO9CZ0wQSzrugKI2w)
* [一本神书：《数据密集型应用系统设计》](https://juejin.cn/post/7018716583816069128)
  

### 《淘宝技术这十年》
* [16 张图解 ｜ 淘宝 10年架构演进](https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&mid=2247499244&idx=1&sn=19d603ded8ee744bef63c270c2910e72&chksm=c27fbfdaf50836cc32b87ed3453c04e2c37e09f22c97a18e215cff3568427db66a30b5de733e&scene=21#wechat_redirect)






## 京东大促流量峰值

### 2021-双11

记录2021年双11大促，8点切场的调用量。

1. 素材中心JSF，总核数 13316

| 接口 | WQPS | WQPM | CPU使用率 | 集群CPU核数 |
|------|------|------|-----------|-------------|
| `queryMatProdForGroups` | 6.6 | 375.7 | 51.4% | 13316 |
| `queryMaterialAdverts` | 19.2 | 1039 | 51.4% | 13316 |
| `queryMatProdForSpecific` | 1.2 | 48.7 | 51.4% | 13316 |
| 总计 | 28.74 | 1548 | 51.4% | 13316 |




2. 投放SOA，总核数 10704


| 接口 | WQPS | WQPM | CPU使用率 | 集群CPU核数 |
|------|------|------|-----------|-------------|
| 投放SOA大接口 | 59.6 | 3377.6 | 31.6% | 10704 |


### 2022-618

2022-618，晚 8 点流量统计
1. 投放 SOA，QPS：121.5w，tp999：705ms，cpu：37.77%
2. 素材中心，QPS :100w，tp999：6146ms，cpu：68.66%






## 一致性哈希
* ref 1-[一致性哈希 | 悟空聊架构](https://my.oschina.net/u/4499317/blog/4943846)
* ref 2-[一致性哈希介绍](https://mp.weixin.qq.com/s/WTz1KA9kOGrqFVTtALJzjQ)


哈希算法中，是对节点的数量进行取模运算。一致性哈希算法中，是对 `2^32` 进行取模运算。


![consitent-hash-1](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/consitent-hash-1.png)


* 如上图所示，「一致性哈希算法」是将整个哈希值空间组成了一个虚拟的圆环，也就是「哈希环」。
* 节点较少 ，哈希环上每个节点实际占据的区间大小不一，最终导致业务对节点的访问「冷热不均」。为此，引入了「虚拟节点映射」来解决分布不均问题。
* 一致性哈希算法本质上是一种「路由寻址」算法，适合简单的路由寻址场景。
* 一致性哈希算法常用在「负载均衡」的架构设计中，如下图所示
    - 将对象和服务器都放置到同一个哈希环
    - 在哈希环上顺时针查找距离这个对象的 hash 值最近的机器，即是这个对象所属的机器
    - 以 o2 对象为例，顺序针找到最近的机器是 cs2，故服务器 cs2 会缓存 o2 对象。而服务器 cs1 则缓存 o1，o3 对象，服务器 cs3 则缓存 o4 对象。


![consitent-hash-1](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/consitent-hash-2.png)



### 一致性Hash的缺点

一致性 Hash 中，存在「缓存抖动」和「数据倾斜」问题。


|   问题     |             描述            |          解决       |
|------------|----------------------------|---------------------|
| 缓存抖动  | 删除节点时，会导致部分数据无法命中，出现缓存抖动，严重的甚至会导致缓存雪崩。比如节点 1 被删除后，节点 1 的请求被分配到顺时针方向的下一个节点 2 上，这可能导致节点 2 的访问量突然增大，再导致节点 2 宕机，继而将请求分配到节点 3 上，如此循环，导致缓存雪崩 | 虚拟节点 |
| 数据倾斜 | 集群中节点过少，大量的数据被分配到同一个节点上，负载不均衡 | 虚拟节点 |



### 虚拟节点
* 一般情况下，虚拟节点比物理节点要多，并相对均匀地分布在哈希环上。
* 虚拟节点可用来解决缓存抖动和数据倾斜问题。

## 如何保证数据库和缓存双写一致性
* ref 1-[Redis与MySQL双写一致性如何保证 | 悟空聊架构](https://my.oschina.net/u/4499317/blog/5262231) 
* ref 2-[如何保证数据库和缓存双写一致性 | 沉默王二](https://mp.weixin.qq.com/s/ItdgKQyb5qEBWXV2WL3Xxg)
* ref 3-[缓存一致性问题图解 | 掘金](https://juejin.cn/post/7070162359267885087)


### 结论
此处先给出结论，推荐使用「先写数据库，再删缓存」的方案来保证双写一致性
1. 操作缓存的时候，到底是删除缓存呢，还是更新缓存？ —— 删除缓存
2. 双写的情况下，先操作数据库还是先操作缓存？—— 先操作数据库

### 问题分析

如果数据库中的某条数据，在放入缓存后又立马被更新了，那么该如何更新缓存呢？如何保证数据库和缓存双写一致性？

针对该问题，若不考虑双写一致性，有4种处理方法
1. 先写缓存，再写数据库（不可取）
2. 先写数据库，再写缓存（不建议使用）
3. 先删缓存，再写数据库（「缓存双删处理」，写数据库之前删除一次缓存，写完数据库后在一定的时间间隔后，再删除一次缓存）
4. **先写数据库，再删缓存**（推荐，虽无法100%保证一致性，但相比其余方案出错概率最小。对于缓存删除失败的场景，可以引入重试机制）

> 缓存删除失败有很多种原因，比如网络波动，机器宕机，机器重启等。


重试机制中异步重试方案有如下几种方案
1. 每次都单独起一个线程，该线程专门做重试的工作。但如果在高并发的场景下，可能会创建太多的线程，导致系统OOM问题，不太建议使用。
2. 将重试的任务交给线程池处理，但如果服务器重启，部分数据可能会丢失。
3. 将重试数据写表，然后使用 elastic-job 等定时任务进行重试。
4. 将重试的请求写入 mq 等消息中间件中，在 mq 的 consumer 中处理。
5. 订阅 mysql 的 binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。


| 方案 | 问题 | 问题出现概率 | 推荐程度 |
|-----|------|------------|---------|
| 更新缓存->更新数据库 | 为了保证数据准确性，数据必须以数据库更新结果为准，所以该方案绝不可行 | 大 | 不推荐|
| 更新数据库->更新缓存 | 并发更新数据库场景下，会将脏数据刷到缓存 | 并发写场景，概率一般 | 写请求较多时会出现不一致问题，不推荐使用 |
| 删除缓存->更新数据库 | 更新数据库之前，若有查询请求，会将脏数据刷到缓存 |并发读场景，概率较大 | 读请求较多时会出现不一致问题，不推荐使用 |
| 更新数据库->删除缓存 | 在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存 | 并发读场景&读操作慢于写操作，概率最小 | 读操作比写操作更慢的情况较少，相比于其他方式出错的概率小一些，勉强推荐 | 



### 谈谈一致性
* 强一致性
* 弱一致性
* 最终一致性


### 3个经典的缓存模式

缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据不一致性的问题。一般我们是如何使用缓存呢？有 3 种经典的缓存使用模式
1. Cache-Aside Pattern（旁路缓存模式）
2. Read-Through/Write-through（读写穿透）：服务端把缓存作为主要数据存储。应用程序通过「抽象缓存层（`Cache Provider`）」跟缓存和DB进行交互。
3. Write-behind（异步缓存写入）：和 Read-Through/Write-through 模式相比，同样使用了「抽象缓存层（`Cache Provider`）」。区别是 Read/Write-Through 采用同步更新缓存和DB的方案，Write-Behind 则是只更新缓存，不直接更新数据库，通过批量异步的方式来更新数据库。


## 系统设计中的三高

* ref 1-[【高并发、高性能、高可用】系统设计经验](https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&mid=2247484957&idx=1&sn=e50e0808cb6503ca7214bdd6fee4f134&utm_source=tuicool&utm_medium=referral)

系统设计中的 “三高” 指的是
1. 高并发
2. 高性能
3. 高可用


|  分类  |   高并发   |    高性能   |  高可用  |
|-------|-----------|------------|----------|
|  指标  |    QPS    |   响应时间  |  4个9（99.99）|
|  手段  | 1.负载均衡；2.池化技术；3.流量漏斗 | 1.缓存技术；2.异步技术；3.I/O（网络，数据，文件）；3.分库分表 | 1.集群；2.熔断；3.降级；4.限流 |



### 高并发
1. 负载均衡
2. 池化技术
3. 流量漏斗


### 高可用

> 高可用的简版回答
> 1. 集群
> 2. 熔断
> 3. 降级
> 4. 限流
> 5. 调用外部服务时，设置一个最大超时时间
> 6. 运维层面，冷热数据隔离部署




稳定性的保证，主要体现在两个大的方面，一个是如何保证服务稳定高可用，一个是出现故障后如何迅速恢复


1. 硬件部署
   * 异地多活
   * 集群部署
   * 冷热数据隔离
   * 弹性扩容
2. 可用性方面
   * 降级
   * 熔断
   * 限流
   * RPC 请求设置最大超市时间，必要的重点服务可设置重试次数
3. 监控告警 & 链路追踪
4. 出现故障后的迅速恢复
   * 做好降级演练
   * 做好灾难演练
   * 机器弹性调整




#### 降级

系统将某些不重要的业务或接口的功能降低，可以只提供部分功能，也可以完全停掉所有不重要的功能。降级的思想是丢车保帅。
#### 熔断

**降级是应对系统自身的故障，而熔断的目的是应对外部系统的故障。**

比如 A 服务的 X 功能依赖 B 服务的某个接口，当 B 服务接口响应很慢时，A 服务 X 功能的响应也会被拖慢，进一步导致了 A 服务的线程都卡在了 X 功能上，A 服务的其它功能也会卡主或拖慢。

此时就需要熔断机制，即 A 服务不在请求 B 这个接口，A 服务内部发现 B 接口就直接返回错误，从而避免整个 A 服务被拖慢。


#### 限流

限流强调的是，只允许系统能够承受的访问量进来，超出的会被丢弃。降级从系统功能优先级角度考虑如何应对故障，而限流则从用户访问压力的角度来考虑如何应对故障。

#### 三者关系
1. 降级强调的是弃车保帅，保证核心功能，降级掉一些不重要的功能，是从系统功能优先级的角度考虑如何保证高可用
2. 限流则从用户访问压力的角度，来考虑如何应对故障。
3. 降级是应对系统自身的故障，而熔断的目的是应对外部系统的故障。
  

熔断是降级方式的一种，降级又是限流的一种方式。




### 高性能（高并发下如何保证接口响应时间降低RT值）

* ref 1-[千万级并发架构中如何降低RT值 | Segmentfault](https://segmentfault.com/a/1190000040832979)
* ref 2-[高并发下如何缩短响应时间](https://cloud.tencent.com/developer/article/1449743)


从整个链路请求角度看，分为两大部分
1. 前端领域
   * DNS 解析
   * 前端资源 CDN 加速
   * ...
2. 后端领域


此处主要针对后端领域的优化展开。可以从下面几个角度出发进行优化
1. 查询数据库
   * 分库分表（最大连接数的处理、单表数据过大的处理）
   * 读写分离
   * 池化思想
   * MySQL 查询优化
   * MyBatis 的一级缓存和二级缓存
2. 访问磁盘数据
   * 磁盘的页缓存，可以借助缓存 I/O ，充分利用系统缓存，降低实际 I/O 的次数
   * 顺序读写，可以用追加写代替随机写，减少寻址开销，加快 I/O 写的速度
   * SSD 代替 HDD，固态硬盘的 I/O 效率远远高于机械硬盘
   * 在需要频繁读写同一块磁盘空间时，可以用 mmap（内存映射）代替 read/write，减少内存的拷贝次数
   * 在需要同步写的场景中，尽量将写请求合并，而不是让每个请求都同步写入磁盘，即可以用 fsync() 取代 O_SYNC
3. 缓存处理
   * Redis 缓存
   * 本地缓存
4. 调用远程服务
   * **最大化并行比例，异步技术**
   * RPC调用中选择合适的序列化协议（msgpack、protobuf等）
   * 网络带宽的处理
5. 合理拆分服务，延迟加载和异步加载






## 面对亿级流量怎么处理
* ref 1-[面对千万级、亿级流量怎么处理](https://heapdump.cn/article/3298255)

面对亿级流量，怎么处理？ 参考上述资料 *ref-1*，此处仅做大纲记录。

* 微服务架构拆分
* 负载均衡
* 消息队列（异步处理，应用解耦，流量削峰）
  1. 如何保证消息不丢失
  2. 如何保证消息不重复消费
  3. 如何保证消息有序性
  4. 如何处理消息堆积
  5. MQ集群的部署和迁移
* 数据库的分库分表（全局唯一ID，主从同步原理）
* Redis缓存设计
  1. 缓存雪崩
  2. 缓存穿透
  3. 缓存击穿
  4. 热Key问题解决和本地二级缓存
* 系统稳定性
  1. 熔断
  2. 限流
  3. 降级 

 



## 项目开发中VO-DTO-BO-PO划分

* [项目开发中，真的有必要定义VO，BO，PO，DO，DTO这些吗](https://www.cnblogs.com/javazhiyin/p/15682813.html)


领域模型命名规约
* 数据对象：`xxxDO`，xxx即为数据表名
* 数据传输对象：`xxxDTO`，xxx为业务领域相关的名称
* 展示对象：`xxxVO`，xxx一般为网页名称


![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/java-po-vo-dto-usage-1.png)





## LowCode
* [低代码工具浅析](https://mp.weixin.qq.com/s/pBS727XUz5Y5upeWvtJ6Lw)


## 网关

* [为什么微服务一定要有网关？](https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247491731&idx=2&sn=76170eac387075c45476a7c1f9a209ab&chksm=eb5065a5dc27ecb3acd84e6d1e325c63981be78c1ad165f6c02671166df72c844426821a6ab5&scene=21#wechat_redirect)


### 什么是服务网关

**服务网关 = 路由转发 + 过滤器**

1. 路由转发：接收一切外界请求，转发到后端的微服务上去
2. 过滤器：在服务网关中可以完成一系列的**横切功能**，例如权限校验、限流以及监控等，这些都可以通过过滤器完成（其实路由转发也是通过过滤器实现的）






## BFF
* [微服务架构中的BFF是什么](https://www.cnblogs.com/edisonchou/p/talk_about_what_is_bff_in_microservices.html)


## SOA



### SOA和微服务架构的区别

* [SOA架构和微服务架构的区别是什么？ | Segmentfault](https://segmentfault.com/a/1190000038817166)




|    功能    |          SOA       |          微服务            |
|------------|--------------------|----------------------------|
|   组件大小 |     大块业务逻辑   |  单独任务或小块业务逻辑    |
|    耦合    |      通常松耦合    |        总是松耦合          |
|  公司架构  |      任何类型      |  小型，专注于功能交叉团队  |
|   **管理**    |    **着重中央管理**    |  **着重分散管理**  |
|   目标     |确保应用能够交互操作|执行新功能，快速拓展开发团队|


> 微服务架构 = 80%的SOA服务架构思想 + 100%的组件化架构思想 + 80%的领域建模思想


* SOA = Service Oriented Architecture，即面向服务的架构：它是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在于操作系统进程中。**SOA提倡将不同应用程序的业务功能封装成“服务”并宿主起来，通常以接口和契约的形式暴露并提供给外界应用访问（通过交换消息），达到不同系统可重用的目的。**

* **微服务是在 SOA 上做的升华，微服务架构强调的一个重点是 “业务需要彻底的组件化和服务化”。** 原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。
* **从管理角度看，SOA着重中央管理，微服务着重分散管理。**




### SOA架构的特点

#### 系统集成

站在系统的角度，解决企业系统间的通信问题，把原先散乱、无规划的系统间的网状结构，梳理成规整、可治理的系统间星形结构。

这一步解决的核心问题是【有序】。


#### 系统的服务化


把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用。站在功能的角度，把业务逻辑抽象成可复用、可组装的服务，通过服务的编排实现业务的 快速再生。

这一步解决的核心问题是【复用】。

#### 业务的服务化

前面两步都是从技术层面来解决系统调用、系统功能复用的问题。第 3 步则是以业务驱动把一个业务单元封装成一项服务。这一步解决的核心问题是【高效】。

站在企业的角度，把企业职能抽象成可复用、可组装的服务；把原先职能化的企业架构转变为服务化的企业架构，进一步提升企业的对外服务能力。


### 微服务架构的特点

#### 通过服务实现组件化

开发者不再需要协调其它服务部署对本服务的影响。

#### 按业务能力来划分服务和开发团队

开发者可以自由选择开发技术，提供 API服务。

#### 去中心化
* 每个微服务有自己私有的数据库持久化业务数据
* **每个微服务只能访问自己的数据库，而不能访问其它服务的数据库**
* **某些业务场景下，需要在一个事务中更新多个数据库。这种情况也不能直接访问其它服务的数据库，而是通过对于微服务进行操作**
* 数据的去中心化，进一步降低了微服务之间的耦合度，不同服务可以采用不同的数据库技术（SQL、NoSQL等）。在复杂的业务场景下，如果包含多个微服务，通常在客户端或者中间层（网关）处理。

#### 基础设施自动化

Java EE 部署架构，通过展现层打包 WARs，业务层划分到 JARs 最后部署为 EAR 一个大包。

而微服务则打开了这个黑盒子，把应用拆分成为一个一个的单个服务，应用docker 技术，不依赖任何服务器和数据模型，是一个全栈应用，可以通过自动化方式独立部署。每个服务运行在自己的进程中，通过轻量的通讯机制联系，经常是基于 HTTP 资源 API，这些服务基于业务能力构建，能实现集中化管理（因为服务太多啦，不集中管理就无法DevOps啦）。




## 领域驱动设计DDD

* [领域驱动设计在互联网业务开发中的实践 | 美团技术](https://tech.meituan.com/2017/12/22/ddd-in-practice.html)
* [如何一步一步用 DDD 设计一个电商网站 - 13篇介绍](https://www.cnblogs.com/Zachary-Fan/p/5991674.html)
  


## B端和C端软件设计的对比

* [互联网中B端客户和C端客户的区别](https://blog.csdn.net/weixin_46048515/article/details/121431955)



一句话总结 B 端和 C 端
1. C 端注重用户体验，请求量级，并发性较大。
2. B 端业务为主，效率至上。一些操作流程有标准化流程可遵循。


两者区别如下

1. 用户群体
   * B 端多角色，有各种菜单权限，数据权限。
   * C 端一般比较单一，单个用户节点
2. 业务形态
   * B 端业务场景复杂，因为多角色嘛。
   * C 端业务场景、逻辑简单、流程相对标准化：用户群体比较固定，场景相对简单，产品要求简单，流程要求相对统一标准化。
3. 用户诉求
   * B 端注重效率、成本、管控。追求服务的稳定性、保证能力、安全性。
   * C 端注重个人的体验，使用简单，有乐趣。

## 负载均衡算法
1. 轮询
2. 加权轮询
3. 随机
4. 最少连接
5. 源地址 hash（IP 绑定策略）
   * 对请求的 IP 进行哈希，映射到对应的机器
   * 来自同一 IP 的请求会固定访问一台服务器，可以解决集群环境下共享 


## 限流算法
1. 计数（固定窗口）
2. 滑动窗口
3. 漏桶算法
4. 令牌桶算法



