# 架构-01-架构设计概览



[TOC]


## 更新
* 2022/05/08，撰写




## 参考资料
* [架构设计面试精讲 | learn.lianglianglee.com](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2)


## 职业发展路线

![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/java-2020/coder-dev-path-1.png)






## 架构经典设计案例
### 《凤凰架构》周志明
* [凤凰架构](https://icyfenix.cn/)




### 《数据密集型应用系统设计》
* [《数据密集型应用系统设计》 | 在线阅读 gitbook](https://vonng.gitbooks.io/ddia-cn/content/)
* [《数据密集型应用系统设计》 | 阅读笔记](https://www.yuque.com/fuxuemingzhu/cdpqne)
* [《数据密集型应用系统设计》 介绍](https://mp.weixin.qq.com/s/kZMVTvO9CZ0wQSzrugKI2w)
* [一本神书：《数据密集型应用系统设计》](https://juejin.cn/post/7018716583816069128)
  

### 《淘宝技术这十年》
* [16 张图解 ｜ 淘宝 10年架构演进](https://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&mid=2247499244&idx=1&sn=19d603ded8ee744bef63c270c2910e72&chksm=c27fbfdaf50836cc32b87ed3453c04e2c37e09f22c97a18e215cff3568427db66a30b5de733e&scene=21#wechat_redirect)






## 京东大促流量峰值

记录2021年双11大促，8点切场的调用量。

1. 素材中心JSF，总核数 13316

| 接口 | WQPS | WQPM | CPU使用率 | 集群CPU核数 |
|------|------|------|-----------|-------------|
| `queryMatProdForGroups` | 6.6 | 375.7 | 51.4% | 13316 |
| `queryMaterialAdverts` | 19.2 | 1039 | 51.4% | 13316 |
| `queryMatProdForSpecific` | 1.2 | 48.7 | 51.4% | 13316 |
| 总计 | 28.74 | 1548 | 51.4% | 13316 |




2. 投放SOA，总核数 10704


| 接口 | WQPS | WQPM | CPU使用率 | 集群CPU核数 |
|------|------|------|-----------|-------------|
| 投放SOA大接口 | 59.6 | 3377.6 | 31.6% | 10704 |





## 一致性哈希
* ref 1-[一致性哈希 | 悟空聊架构](https://my.oschina.net/u/4499317/blog/4943846)
* ref 2-[一致性哈希介绍](https://mp.weixin.qq.com/s/WTz1KA9kOGrqFVTtALJzjQ)


哈希算法中，是对节点的数量进行取模运算。一致性哈希算法中，是对 `2^32` 进行取模运算。


![consitent-hash-1](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/consitent-hash-1.png)


* 如上图所示，「一致性哈希算法」是将整个哈希值空间组成了一个虚拟的圆环，也就是「哈希环」。
* 节点较少 ，哈希环上每个节点实际占据的区间大小不一，最终导致业务对节点的访问「冷热不均」。为此，引入了「虚拟节点映射」来解决分布不均问题。
* 一致性哈希算法本质上是一种「路由寻址」算法，适合简单的路由寻址场景。
* 一致性哈希算法常用在「负载均衡」的架构设计中，如下图所示
    - 将对象和服务器都放置到同一个哈希环
    - 在哈希环上顺时针查找距离这个对象的 hash 值最近的机器，即是这个对象所属的机器
    - 以 o2 对象为例，顺序针找到最近的机器是 cs2，故服务器 cs2 会缓存 o2 对象。而服务器 cs1 则缓存 o1，o3 对象，服务器 cs3 则缓存 o4 对象。


![consitent-hash-1](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/consitent-hash-2.png)






## 如何保证数据库和缓存双写一致性
* ref 1-[Redis与MySQL双写一致性如何保证 | 悟空聊架构](https://my.oschina.net/u/4499317/blog/5262231) 
* ref 2-[如何保证数据库和缓存双写一致性 | 沉默王二](https://mp.weixin.qq.com/s/ItdgKQyb5qEBWXV2WL3Xxg)
* ref 3-[缓存一致性问题图解 | 掘金](https://juejin.cn/post/7070162359267885087)


### 结论
此处先给出结论，推荐使用「先写数据库，再删缓存」的方案来保证双写一致性
1. 操作缓存的时候，到底是删除缓存呢，还是更新缓存？ —— 删除缓存
2. 双写的情况下，先操作数据库还是先操作缓存？—— 先操作数据库

### 问题分析

如果数据库中的某条数据，在放入缓存后又立马被更新了，那么该如何更新缓存呢？如何保证数据库和缓存双写一致性？

针对该问题，若不考虑双写一致性，有4种处理方法
1. 先写缓存，再写数据库（不可取）
2. 先写数据库，再写缓存（不建议使用）
3. 先删缓存，再写数据库（「缓存双删处理」，写数据库之前删除一次缓存，写完数据库后在一定的时间间隔后，再删除一次缓存）
4. **先写数据库，再删缓存**（推荐，虽无法100%保证一致性，但相比其余方案出错概率最小。对于缓存删除失败的场景，可以引入重试机制）

重试机制中异步重试方案有如下几种方案
1. 每次都单独起一个线程，该线程专门做重试的工作。但如果在高并发的场景下，可能会创建太多的线程，导致系统OOM问题，不太建议使用。
2. 将重试的任务交给线程池处理，但如果服务器重启，部分数据可能会丢失。
3. 将重试数据写表，然后使用 elastic-job 等定时任务进行重试。
4. 将重试的请求写入 mq 等消息中间件中，在 mq 的 consumer 中处理。
5. 订阅 mysql 的 binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。


| 方案 | 问题 | 问题出现概率 | 推荐程度 |
|-----|------|------------|---------|
| 更新缓存->更新数据库 | 为了保证数据准确性，数据必须以数据库更新结果为准，所以该方案绝不可行 | 大 | 不推荐|
| 更新数据库->更新缓存 | 并发更新数据库场景下，会将脏数据刷到缓存 | 并发写场景，概率一般 | 写请求较多时会出现不一致问题，不推荐使用 |
| 删除缓存->更新数据库 | 更新数据库之前，若有查询请求，会将脏数据刷到缓存 |并发读场景，概率较大 | 读请求较多时会出现不一致问题，不推荐使用 |
| 更新数据库->删除缓存 | 在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存 | 并发读场景&读操作慢于写操作，概率最小 | 读操作比写操作更慢的情况较少，相比于其他方式出错的概率小一些，勉强推荐 | 



### 谈谈一致性
* 强一致性
* 弱一致性
* 最终一致性


### 3个经典的缓存模式

缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据不一致性的问题。一般我们是如何使用缓存呢？有 3 种经典的缓存使用模式
1. Cache-Aside Pattern（旁路缓存模式）
2. Read-Through/Write-through（读写穿透）：服务端把缓存作为主要数据存储。应用程序通过「抽象缓存层（`Cache Provider`）」跟缓存和DB进行交互。
3. Write-behind（异步缓存写入）：和 Read-Through/Write-through 模式相比，同样使用了「抽象缓存层（`Cache Provider`）」。区别是 Read/Write-Through 采用同步更新缓存和DB的方案，Write-Behind 则是只更新缓存，不直接更新数据库，通过批量异步的方式来更新数据库。


## 系统设计中的三高

* ref 1-[【高并发、高性能、高可用】系统设计经验](https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&mid=2247484957&idx=1&sn=e50e0808cb6503ca7214bdd6fee4f134&utm_source=tuicool&utm_medium=referral)

系统设计中的 “三高” 指的是
1. 高并发
2. 高性能
3. 高可用


|  分类  |   高并发   |    高性能   |  高可用  |
|-------|-----------|------------|----------|
|  指标  |    QPS    |   响应时间  |  4个9（99.99）|
|  手段  | 1.负载均衡；2.池化技术；3.流量漏斗 | 1.缓存技术；2.异步技术；3.I/O（网络，数据，文件）；3.分库分表 | 1.集群；2.熔断；3.降级；4.限流 |



## 面对亿级流量怎么处理
* ref 1-[面对千万级、亿级流量怎么处理](https://heapdump.cn/article/3298255)

面对亿级流量，怎么处理？ 参考上述资料 *ref-1*，此处仅做大纲记录。

* 微服务架构拆分
* 负载均衡
* 消息队列（异步处理，应用解耦，流量削峰）
  1. 如何保证消息不丢失
  2. 如何保证消息不重复消费
  3. 如何保证消息有序性
  4. 如何处理消息堆积
  5. MQ集群的部署和迁移
* 数据库的分库分表（全局唯一ID，主从同步原理）
* Redis缓存设计
  1. 缓存雪崩
  2. 缓存穿透
  3. 缓存击穿
  4. 热Key问题解决和本地二级缓存
* 系统稳定性
  1. 熔断
  2. 限流
  3. 降级 

 






## 项目开发中VO-DTO-BO-PO划分

* [项目开发中，真的有必要定义VO，BO，PO，DO，DTO这些吗](https://www.cnblogs.com/javazhiyin/p/15682813.html)


领域模型命名规约
* 数据对象：`xxxDO`，xxx即为数据表名
* 数据传输对象：`xxxDTO`，xxx为业务领域相关的名称
* 展示对象：`xxxVO`，xxx一般为网页名称


![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/java-po-vo-dto-usage-1.png)





## LowCode
* [低代码工具浅析](https://mp.weixin.qq.com/s/pBS727XUz5Y5upeWvtJ6Lw)


## 网关

* [为什么微服务一定要有网关？](https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247491731&idx=2&sn=76170eac387075c45476a7c1f9a209ab&chksm=eb5065a5dc27ecb3acd84e6d1e325c63981be78c1ad165f6c02671166df72c844426821a6ab5&scene=21#wechat_redirect)


### 什么是服务网关

**服务网关 = 路由转发 + 过滤器**

1. 路由转发：接收一切外界请求，转发到后端的微服务上去
2. 过滤器：在服务网关中可以完成一系列的**横切功能**，例如权限校验、限流以及监控等，这些都可以通过过滤器完成（其实路由转发也是通过过滤器实现的）






## BFF
* [微服务架构中的BFF是什么](https://www.cnblogs.com/edisonchou/p/talk_about_what_is_bff_in_microservices.html)


## SOA



### SOA和微服务架构的区别

* [SOA架构和微服务架构的区别是什么？ | Segmentfault](https://segmentfault.com/a/1190000038817166)




|    功能    |          SOA       |          微服务            |
|------------|--------------------|----------------------------|
|   组件大小 |     大块业务逻辑   |  单独任务或小块业务逻辑    |
|    耦合    |      通常松耦合    |        总是松耦合          |
|  公司架构  |      任何类型      |  小型，专注于功能交叉团队  |
|   **管理**    |    **着重中央管理**    |  **着重分散管理**  |
|   目标     |确保应用能够交互操作|执行新功能，快速拓展开发团队|


> 微服务架构 = 80%的SOA服务架构思想 + 100%的组件化架构思想 + 80%的领域建模思想


* SOA = Service Oriented Architecture，即面向服务的架构：它是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在于操作系统进程中。**SOA提倡将不同应用程序的业务功能封装成“服务”并宿主起来，通常以接口和契约的形式暴露并提供给外界应用访问（通过交换消息），达到不同系统可重用的目的。**

* **微服务是在 SOA 上做的升华，微服务架构强调的一个重点是 “业务需要彻底的组件化和服务化”。** 原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。
* **从管理角度看，SOA着重中央管理，微服务着重分散管理。**




### SOA架构的特点

#### 系统集成

站在系统的角度，解决企业系统间的通信问题，把原先散乱、无规划的系统间的网状结构，梳理成规整、可治理的系统间星形结构。

这一步解决的核心问题是【有序】。


#### 系统的服务化


把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用。站在功能的角度，把业务逻辑抽象成可复用、可组装的服务，通过服务的编排实现业务的 快速再生。

这一步解决的核心问题是【复用】。

#### 业务的服务化

前面两步都是从技术层面来解决系统调用、系统功能复用的问题。第 3 步则是以业务驱动把一个业务单元封装成一项服务。这一步解决的核心问题是【高效】。

站在企业的角度，把企业职能抽象成可复用、可组装的服务；把原先职能化的企业架构转变为服务化的企业架构，进一步提升企业的对外服务能力。


### 微服务架构的特点

#### 通过服务实现组件化

开发者不再需要协调其它服务部署对本服务的影响。

#### 按业务能力来划分服务和开发团队

开发者可以自由选择开发技术，提供 API服务。

#### 去中心化
* 每个微服务有自己私有的数据库持久化业务数据
* **每个微服务只能访问自己的数据库，而不能访问其它服务的数据库**
* **某些业务场景下，需要在一个事务中更新多个数据库。这种情况也不能直接访问其它服务的数据库，而是通过对于微服务进行操作**
* 数据的去中心化，进一步降低了微服务之间的耦合度，不同服务可以采用不同的数据库技术（SQL、NoSQL等）。在复杂的业务场景下，如果包含多个微服务，通常在客户端或者中间层（网关）处理。

#### 基础设施自动化

Java EE 部署架构，通过展现层打包 WARs，业务层划分到 JARs 最后部署为 EAR 一个大包。

而微服务则打开了这个黑盒子，把应用拆分成为一个一个的单个服务，应用D
docker 技术，不依赖任何服务器和数据模型，是一个全栈应用，可以通过自动化方式独立部署。每个服务运行在自己的进程中，通过轻量的通讯机制联系，经常是基于 HTTP 资源 API，这些服务基于业务能力构建，能实现集中化管理（因为服务太多啦，不集中管理就无法DevOps啦）。




## 领域驱动设计DDD

* [领域驱动设计在互联网业务开发中的实践 | 美团技术](https://tech.meituan.com/2017/12/22/ddd-in-practice.html)
  
