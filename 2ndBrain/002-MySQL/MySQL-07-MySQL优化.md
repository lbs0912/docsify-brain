


# MySQL-07-MySQL优化

[TOC]

## 更新
* 2022/05/15，撰写


## 参考资料
* [《MySQL是怎样运行的》从根儿上理解 MySQL](https://juejin.cn/book/6844733769996304392)，「基于规则的优化」章节
* [书写高质量 SQL 的 30 条建议 | 掘金](https://juejin.im/post/5e624d156fb9a07ca80ab6f2)
* [项目中常用的 19 条 MySQL 优化 | 掘金](https://zhuanlan.zhihu.com/p/66582084)



## 慢查询
* [MySQL索引原理及慢查询优化 | 美团技术](https://tech.meituan.com/2014/06/30/mysql-index.html)
* [SQL 查询速度慢原因及优化方法 | CSDN](https://blog.csdn.net/GX_1_11_real/article/details/88699445)



### 如何定位慢查询
1. 慢查询日志
2. 服务监控


### 慢查询的可能原因

SQL 查询慢的可能原因如下
1. 没有索引或者没有用到索引（这是查询慢最常见的问题，是程序设计的缺陷）
2. I/O 吞吐量小，形成了瓶颈效应
3. 没有创建计算列导致查询不优化
4. 内存不足
5. 网络速度慢
6. 查询出的数据量过大（可以采用多次查询，其他的方法降低数据量）
7. 锁或者死锁（这也是查询慢最常见的问题，是程序设计的缺陷）
8. sp_lock，sp_who，活动的用户查看，原因是读写竞争资源。
9. 返回了不必要的行和列
10. 查询语句不好，没有优化


### 如何优化

* [MySQL六十六问，两万字+五十图详解](https://mp.weixin.qq.com/s/zSTyZ-8CFalwAYSB0PN6wA)



![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2023/mysql-slow-query-improve-1.png)



## MySQL 优化
* ref 1-[MySQL 优化的思路](https://mp.weixin.qq.com/s/jnVyMW18Oj9LAS0bPN1NKg)


「MySQL 优化」，有如下几个方面
1. SQL 优化
2. 设计优化
3. 硬件优化


### SQL 优化


#### 分页优化

```sql
select * from table 
where type = 2 and level = 9 
order by id asc 
limit 190289,10;
```


对上述深翻页，有如下优化思路

1. 延迟关联

先通过 `where` 条件提取出主键，在将该表与原数据表关联，通过主键 id 提取数据行，而不是通过原来的二级索引提取数据行。

```sql
select a.* from table a, 
(select id from table where type = 2 and level = 9 order by id asc limit 190289,10 ) b 
where a.id = b.id
```


2. 书签方式

找到 `limit` 第一个参数对应的主键值，再根据这个主键值再去过滤并 `limit`。

```sql
select * from table 
where id > (select * from table where type = 2 and level = 9 order by id asc limit 190289, 1) 
limit 10;
```



#### 索引优化
1. 建立覆盖索引，避免回表
2. 在 MySQL 5.0 之前的版本尽量避免使用 or 查询，可以使用 union 或者子查询来替代
   * 早期的 MySQL 版本中，使用 or 查询可能会导致索引失效
   * MySQL 5.0 后，引入了索引合并来避免该问题
3. 避免在 `where` 查询条件中使用 `!=` 或者 `<>` 操作符
4. 适当使用前缀索引


#### Join 优化
1. 小表驱动大表
2. 避免 Join 关联太多的表


#### 排序优化

利用索引扫描做排序。

* MySQL 有 2 种方式生成有序结果，其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的。
* 如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机 IO，通常会比顺序全表扫描还慢


#### 其他
1. 查询具体的字段而非全部字段
2. 优化子查询
3. 不要在列上进行运算操作
4. 学会使用 `explain` 和慢查询日志定位问题
### 设计优化

1. 尽量避免使用 NULL
2. 最小数据长度
3. 使用最简单数据类型
4. 尽量少定义 text 类型
5. 适当分表、分库策略
6. VARCHAR 和 CHAR 的合理选取
7. 当数据较好范式化时，修改的数据更少


> 第一范式：字段不可分割，数据库默认支持
> 
> 第二范式：消除对主键的部分依赖，可以在表中加上一个与业务逻辑无关的字段作为主键，比如用自增 ID
> 
> 第三范式：消除对主键的传递依赖，可以将表拆分，减少数据冗余



### 硬件优化


#### 磁盘

磁盘应该尽量使用有高性能读写能力的磁盘，比如固态硬盘，这样就可以减少 I/O 运行的时间，从而提高了 MySQL 整体的运行效率。

磁盘也可以尽量使用多个小磁盘而不是一个大磁盘，因为磁盘的转速是固定的，有多个小磁盘就相当于拥有多个并行运行的磁盘一样。

#### 网络

保证网络带宽的通畅（低延迟）以及够大的网络带宽是 MySQL 正常运行的基本条件，如果条件允许的话也可以设置多个网卡，以提高网络高峰期 MySQL 服务器的运行效率。

#### 内存

MySQL 服务器的内存越大，那么存储和缓存的信息也就越多，而内存的性能是非常高的，从而提高了整个 MySQL 的运行效率。


## MySQL 开发的 36 条军规
### 核心军规

1. 尽量不在数据库做运算
2. 控制单表数据量 纯 INT 不超过 10M 条，含 Char 不超过 5M 条
3. 保持表身段苗条
4. 平衡范式和冗余
5. 拒绝大 SQL，复杂事务，大批量任务
### 字段类军规

1. 用好数值字段，尽量简化字段位数
2. 把字符转化为数字
3. 优先使用 Enum 或 Set
4. 避免使用 Null 字段
5. 少用并拆封 Text/Blob
6. 不在数据库中存图片

### 索引类军规

1. 谨慎合理添加索引
2. 字符字段必须建立前缀索引
3. 不在索引列做运算
4. 自增列或全局 ID 做 InnoDB 主键
5. 尽量不用外键

### SQL类军规

1. SQL 尽可能简单
2. 保持事务连接短小
3. 尽可能避免使用 SP/Trigger/Function
4. 尽量不用 `Select *`
5. 改写 `Or` 为 `IN()`
6. 改写 `Or` 为 `Union`
7. 避免负向查询和 `%` 前缀模糊查询
8. `Count` 不要使用在可 `Null` 的字段上面
9. 减少 `Count(*)`（会计数值为 null 的情况）
10. `limit` 高效分页，`SELECT * FROM message WHERE id > 9527 (or sub select) limit 10`
11. 使用 `Union ALL` 而不用 `Union`（`union` 会进行去重）
12. 分解链接，保证高并发
13. `group By` 去除排序
14. 同数据类型的列值比较
15. Load Data 导入数据，比 Insert 快 20 倍
16. 打散大批量更新，尽量凌晨操作

### 约定类军规

1. 隔离线上线下
2. 禁止未经 DBA 认证的子查询
3. 永远不在程序段显式加锁
4. 表字符集统一使用 UTF8MB4






## 高质量 SQL 建议

1. 查询 SQL 尽量不要使用 `select *`，而是 `select` 具体字段
2. 如果查询结果只有一条或者只要最大/最小一条记录，建议用 `limit 1`
3. 应尽量避免在 `where` 子句中使用 `or` 来连接条件
4. 优化 `limit` 分页
5. 优化 `like` 语句
6. 使用 `where` 条件限定要查询的数据，避免返回多余的行
7. 尽量避免在索引列上使用 mysql 的内置函数
8. 应尽量避免在 `where` 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫描
9. `inner join` 、`left join`、`right join`，优先使用 `inner join`，如果是 `left join`，左边表结果尽量小
10. 应尽量避免在 `where` 子句中使用 `!=` 或 `<>` 操作符，否则将引擎放弃使用索引而进行全表扫描
11. 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则
12. 对查询进行优化，应考虑在 `where` 及 `order by` 涉及的列上建立索引，尽量避免全表扫描
13. 如果插入数据过多，考虑批量插入
14. 在适当的时候，使用覆盖索引
15. 慎用 `distinct` 关键字
16. 删除冗余和重复索引
17. 如果数据量较大，优化你的修改/删除语句
18. `where` 子句中考虑使用默认值代替 `null`
19. 不要有超过 5 个以上的表连接
20. `exist` & `in` 的合理利用
21. 尽量用 `union all` 替换 `union`
22. 索引不宜太多，一般 5 个以内
23. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型
24. 索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段
25. 尽量避免向客户端返回过多数据量
26. 当在 SQL 语句中连接多个表时，请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰
27. 尽可能使用 `varchar/nvarchar` 代替 `char/nchar`
28. 为了提高 `group by` 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉
29. 如果字段类型是字符串，`where` 时一定用引号括起来，否则索引失效
30. 使用 `explain` 分析 SQL 的执行




### IN包含的值不应过多

MySQL 对于 `IN` 做了相应的优化，即将 `IN` 中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。

例如，`select id from table_name where num in(1,2,3)` 中，对于连续的数值，能用 `between` 就不要用 `in` 了；再或者使用连接来替换。


### order by 性能优化
* ref 1-[面试官：order by 怎么优化](https://mp.weixin.qq.com/s?__biz=MzU2MDY0NDA1MQ==&mid=2247492422&idx=1&sn=5699eb9b72b32741498c94269bc7a578&scene=21#wechat_redirect)


#### sort_buffer

`order by` 排序时，MySQL 会为排序开辟一块内存区域（`sort_buff`）
1. 如果要排序的数据量小于 `sort_buffer_size`，排序就在内存中完成
2. 如果排序数据量太大，超出内存限制，就需要使用磁盘临时文件辅助排序


#### 全字段排序和rowId排序

在 `order by` 排序时，若需要查询的内容（`select` 查询出的所有字段信息）可以在内存区域（`sort_buff`）中存下，则会将全部内容存放到内存中，进行全字段排序，这样做的好处是排序后无需进行回表。

若查询内容不能在内存区域（`sort_buff`）中存下，则会进行 `rowId` 排序，即只将 `order by col` 中的 `col` 信息和主键信息存放到内存中。该情况下，排序后，还需要进行回表补充查询的其余字段信息。

所以，尽可能的减少查询字段，避免使用 `select *`。


### group by 性能优化
* ref 1-[阿里二面：group by 怎么优化](https://mp.weixin.qq.com/s/bLTshwVwJsMKk4Zudytf9A)


`group by` 是需要创建临时表并且排序的。

对于该操作的性能优化，有以下4个方面
1. 分组字段加索引
2. `order by null` 不排序
3. 尽量使用「内存临时表」。MySQL 临时表分内存临时表和磁盘临时表。`group by` 在执行过程中使用内存临时表还是不够用，那就会使用磁盘临时表。内存临时表默认大小是 16M。
4. SQL_BIG_RESULT
   * 如果数据量实在过大，大到内存临时表都不够用了，这时就转向使用磁盘临时表。而发现不够用再转向这个过程也是很耗时的，那我们有没有一种方法，可以告诉 mysql 从一开始就使用磁盘临时表呢？
   * 有的，在 group by 语句中加入 SQL_BIG_RESULT 提示 MySQL 优化器直接用磁盘临时表。优化器分析，磁盘临时表是 B+ 树存储，存储效率不如数组来得高。所以直接用数组存储。




