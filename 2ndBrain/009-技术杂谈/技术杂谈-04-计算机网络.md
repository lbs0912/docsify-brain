
# 技术杂谈-04-计算机网络

[TOC]


## 更新
* 2022/05/05，撰写



## 高频面试汇总

### HTTP的Keep-Alive和TCP的keepAlive
* ref 1-[TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗](https://blog.51cto.com/u_14888059/3812567)
#### HTTP的keep-alive

在 HTTP 1.0 以前，每个 http 请求都要求打开一个 TCP socket 连接，并且使用一次之后就断开这个 TCP 连接，这会导致频繁地创建和销毁 TCP。HTTP 1.1 通过使用 keep-alive 可以改善这种状态，即在一次 TCP 连接中可以持续发送多份数据而不会断开连接。



在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 `Keep-Alive`，它必须在请求的包头中添加

```s
Connection: Keep-Alive
```

然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中。

```s
Connection: Keep-Alive
```


从 HTTP 1.1 开始， 就默认是开启了 `Keep-Alive`，如果要关闭 `Keep-Alive`，需要在 HTTP 请求的包头里添加。

```s
Connection:close
```

可能有的同学会问，如果使用了 HTTP 长连接，如果客户端完成一个 HTTP 请求后，就不再发起新的请求，此时这个 TCP 连接一直占用着不是挺浪费资源的吗？

没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供 `keepalive_timeout` 参数，用来指定 HTTP 长连接的超时时间。

比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会启动一个定时器，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，就会触发回调函数来释放该连接。



#### TCP的keepAlive

TCP 的 keepAlive，是 TCP 协议栈为了检测连接状况而使用的一种「保活机制」。

当 TCP 空闲一定时间后会发送心跳包给对方
1. 如果对端回复 ACK 后，就认为对端是存活的，重置定时器。
2. 如果对端回复 RST 应答（对端崩溃或者其他原因，导致的复位），那就关闭该连接。
3. 如果对端无任何回应，那就会出发超时重传，直到达到重传的次数，如果对端依然没有回复，那么就关闭该连接。


#### 二者区别
1. 网络层级不同
   * HTTP 位于应用层
   * 而 TCP 位于传输层
2. 作用不同
   * 长连接：HTTP 是为了重用 TCP，避免每次请求，都重复创建 TCP，所以引入了 `keep-alive`
   * 保活机制：TCP 的 keepAlive 是一种保活机制，检测对端是否依然存活
3. 是否有超时时间
   * HTTP 受限于浏览器资源，一般都会提供 `keepalive_timeout` 参数，用来指定 HTTP 长连接的超时时间
   * TCP 则没有超时时间设定
4. 字母拼写
   * HTTP 中为 `-` 连接，即 `keep-alive`
   * TCP 中为驼峰命名，即 `keepAlive`


## 一次URL请求的过程
* ref 1-[访问一个URL经历了哪些过程 | CSDN](https://blog.csdn.net/Myxyj/article/details/80027700)
* ref 2-[浏览器从输入网址到页面展示的过程](https://cloud.tencent.com/developer/article/1879758)



一次 URL 请求，整个流程大体如下
1. 客户端获取 URL 
2. DNS 解析
3. TCP 连接
4. 发送 HTTP 请求
5. 服务器处理请求
6. 返回报文
7. 浏览器解析渲染页面 
8. TCP 断开连接


![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2023/url-request-1.png)


下面从「客户端」和「服务端」角度出发，描述请求过程的各个步骤

> 客户端
1. （应用层开始）获取 URL，通过负责域名解析的 DNS 服务获取网址的 IP 地址，根据 HTTP 协议生成 HTTP 请求报文。（应用层结束）
2. （传输层开始）根据 TCP 协议，建立从客户端到服务端的连接，该过程涉及TCP 建立连接的三次握手。（传输层结束）
3. （网络层开始）根据 IP 协议（传输数据），ARP 协议（获取 MAC 地址），OSPF 协议（选择最优路径），搜索服务器地址，一边中转一边传输数据。（网络层结束）
4. （数据链路层开始）到达后通过数据链路层，物理层负责 0、1 比特流与物理设备电压高低，光的闪灭之间的互换。数据链路层负责将 0、1 序列划分为数据帧，从一个节点传输到临近的另一个节点，这些节点是通过 MAC 来唯一标识的（MAC，物理地址，一个主机会有一个 MAC 地址）。（数据链路层结束）

> 服务端
1. 数据到达数据链路层
2. 传递至网络层
3. 再通过传输层（根据 TCP 协议接收请求报文并重组报文段）
4. 再通过应用层（通过 HTTP 协议对请求的内容进行处理） 
5. 再通过应用层 -> 传输层 -> 网络层 -> 数据链路层 -> 到达客户端

> 客户端
1. 接收来自服务端的相应，通过数据链路层 -> 网络层 -> 传输层（根据 TCP 协议接收响应报文并重组） -> 应用层（HTTP 协议对响应进行处理） -> 浏览器渲染页面 -> 断开连接协议四次挥手 




### DNS解析过程


因为浏览器不能直接通过域名找到对应的服务器 IP 地址，所以需要进行 DNS 解析，查找到对应的 IP 地址进行访问。DNS 解析流程如下。

![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2023/dns-step-1.png)


1. 在浏览器中输入 `hzfe.org` 域名，操作系统检查「浏览器缓存」和「本地的 hosts 文件」中，是否有这个网址记录，有则从记录里面找到对应的 IP 地址，完成域名解析。
2. 查找「本地 DNS 解析器缓存」中，是否有这个网址记录，有则从记录里面找到对应的 IP 地址，完成域名解析。
3. 使用 TCP/IP 参数中设置的 DNS 服务器进行查询。如果要查询的域名包含在本地配置区域资源中，则返回解析结果，完成域名解析。
4. 检查本地 DNS 服务器是否缓存该网址记录，有则返回解析结果，完成域名解析。
5. 本地 DNS 服务器发送查询报文至根 DNS 服务器，根 DNS 服务器收到请求后，用顶级域 DNS 服务器地址进行响应。
6. 本地 DNS 服务器发送查询报文至顶级域 DNS 服务器。顶级域 DNS 服务器收到请求后，用权威 DNS 服务器地址进行响应。
7. 本地 DNS 服务器发送查询报文至权威 DNS 服务器，权威 DNS 服务器收到请求后，用 `hzfe.org` 的 IP 地址进行响应，完成域名解析。
8. 查询通常遵循以上流程，从请求主机到本地 DNS 服务器的查询是递归查询，DNS 服务器获取到所需映射的查询过程是迭代查询。



## TCP的三次握手和四次挥手
* [TCP 的三次握手和四次挥手 | 掘金](https://juejin.cn/post/6844903958624878606)


![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2023/tcp-establish-3-handshake-0.png)



### 三次握手

三次握手（Three-way Handshake）其实就是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。






#### 过程（简版）

* ref 1-[TCP三次握手](https://www.eet-china.com/mp/a44399.html)


建立连接时，客户端与服务器交互需要 3 个数据包。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。
1. 第 1 次握手：客户端发送 SYN 报文，并进入 SYN_SENT 状态，等待服务器的确认；
2. 第 2 次握手：服务器收到 SYN 报文，需要给客户端发送 ACK 确认报文，同时服务器也要向客户端发送一个 SYN 报文，所以也就是向客户端发送 SYN + ACK 报文，此时服务器进入 SYN_RCVD 状态；
3. 第 3 次握手：客户端收到 SYN + ACK 报文，向服务器发送确认包，客户端进入 ESTABLISHED 状态。待服务器收到客户端发送的 ACK 包也会进入 ESTABLISHED 状态，完成三次握手。


#### 过程

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。

进行三次握手的过程如下。

1. 第 1 次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 `SYN_SEND` 状态。

首部的同步位 SYN=1，初始序号 seq=x，SYN=1 的报文段不能携带数据，但要消耗掉一个序号。

2. 第 2 次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 `SYN_RCVD` 的状态。

在确认报文段中 SYN=1，ACK=1，确认号 ack=x+1，初始序号 seq=y。


3. 第 3 次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

确认报文段 ACK=1，确认号 ack=y+1，序号 seq=x+1（初始为 seq=x，第二个报文段所以要 +1），**ACK 报文段可以携带数据，不携带数据则不消耗序号。**


发送第一个 SYN 的一端将执行主动打开（active open），接收这个 SYN 并发回下一个 SYN 的另一端执行被动打开（passive open）。

总结而言，在 Socket 编程中，客户端执行 `connect()` 时，将触发三次握手，如下图所示。


![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2023/tcp-establish-3-handshake-1.png)




#### 为什么需要三次握手，两次不行吗

弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。
1. 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
2. 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。**不过此时服务器并不能确认客户端的接收能力是否正常。**
3. 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。



#### 什么是半连接队列？

服务器第一次收到客户端的 SYN 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为「半连接队列」。

当然还有一个「全连接队列」，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

这里在补充一点关于 `SYN-ACK` 重传次数的问题.

服务器发送完 `SYN-ACK` 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......

#### ISN(Initial Sequence Number)是固定的吗

当一端为建立连接而发送它的 `SYN` 时，它为连接选择一个初始序号。ISN 随时间而变化，因此每个连接都将具有不同的 ISN。ISN 可以看作是一个 32 比特的计数器，每 4ms 加 1。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。

三次握手的其中一个重要功能是客户端和服务端交换 ISN（Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。



#### 三次握手过程中可以携带数据吗

**其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据。**

为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，它已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。


### 四次挥手


建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由 TCP 的半关闭（half-close）造成的。**所谓的半关闭，其实就是 TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。**


TCP 的连接的拆除需要发送四个包，因此称为四次挥手（Four-way handshake)，客户端或服务器均可主动发起挥手动作。


#### 过程（简版）
> TCP 断开时候的四次握手（TCP 是双向连接）

1. 当主机 A 完成数据传输后，将控制位 FIN 置 1，提出停止 TCP 连接的请求
2. 主机 B 收到 FIN 后对其作出响应，确认这一方向上的 TCP 连接将关闭，将ACK置 1
3. 由 B 端再提出反方向的关闭请求，将 FIN 置 1
4. 主机 A 对主机 B 的请求进行确认，将 ACK 置 1，双方向的关闭结束

#### 过程

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下。
1. 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭 TCP 连接，进入 FIN_WAIT1（终止等待1）状态，等待服务端的确认。
2. 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入 CLOSE_WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入 FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入 LAST_ACK（最后确认）状态，等待客户端的确认。
4. 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入 TIME_WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，客户端才进入 CLOSED 状态。

**收到一个 FIN 只意味着在这一方向上没有数据流动。** 客户端执行主动关闭并进入 TIME_WAIT 是正常的，服务端通常执行被动关闭，不会进入 TIME_WAIT 状态。

在 Socket 编程中，任何一方执行 `close()` 操作即可产生挥手操作。四次挥手的过程如下图所示。





![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2023/tcp-un-establish-4-handshake-1.png)


#### 挥手为什么需要四次

因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。

但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，“你发的 FIN 报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。



#### 2MSL等待状态

TIME_WAIT 状态也成为 2MSL 等待状态。每个具体 TCP 实现必须选择一个报文段最大生存时间 MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为 TCP 报文段以 IP 数据报在网络内传输，而 IP 数据报则有限制其生存时间的 TTL 字段。

对一个具体实现所给定的 MSL 值，处理的原则是：当 TCP 执行一个主动关闭，并发回最后一个 ACK，该连接必须在 TIME_WAIT 状态停留的时间为 2 倍的MSL。这样可让 TCP 再次发送最后的 ACK 以防这个 ACK 丢失（另一端超时并重发最后的 FIN）。

这种 2MSL 等待的另一个结果是这个 TCP 连接在 2MSL 等待期间，定义这个连接的插口（客户的 IP 地址和端口号，服务器的 IP 地址和端口号）不能再被使用。这个连接只能在 2MSL 结束后才能再被使用。


#### 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态

理论上，4 个报文都发送完毕，就可以直接进入 CLOSE 状态了，但是可能网络是不可靠的，有可能最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。
## 计算机网络模型

计算网络模型，常用的划分有
1. OSI（`Open System Interconnection/Reference Model`，开放系统互联参考模型）的 7 层网络模型
2. TCP/IP 五层协议
3. TCP/IP 四层协议



![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/osi-tcp-ip-network-1.png)


OSI 7 层网络模型的说明如下
1. 物理层 
2. 数据链路层
   * 数据链路层为网络层提供可靠的数据传输
   * 基本数据单位为帧；
   * 主要的协议：以太网协议
   * 两个重要设备名称：网桥和交换机
3. 网络层
   * 负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。
   * 基本数据单位为 IP 数据报。
   * 包含的主要协议
     * IP 协议（Internet Protocol，因特网互联协议）
     * ICMP 协议（Internet Control Message Protocol，因特网控制报文协议）
     * ARP 协议（Address Resolution Protocol，地址解析协议）
     * RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）
   * 重要的设备：路由器
4. 传输层
   * 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题
   * 包含的主要协议
     * TCP 协议（Transmission Control Protocol，传输控制协议）
     * UDP 协议（User Datagram Protocol，用户数据报协议）
   * 重要设备：网关
5. 会话层
6. 表示层
7. 应用层
   * 数据传输基本单位为报文
   * 包含的主要协议
     * FTP（文件传送协议）
     * Telnet（远程登录协议）
     * DNS（域名解析协议）
     * SMTP（邮件传送协议）
     * POP3 协议（邮局协议）
     * HTTP 协议（Hyper Text Transfer Protocol）
     * NFS（网络文件系统）


| 应用层协议 |  说明   | 对应的传输层协议 |
|----------|---------|----------------|
| FTP | 文件传送协议 | TCP |  
| Telnet | 远程登录协议 | TCP | 
| SMTP | 邮件传送协议 | TCP | 
| POP3 | 邮局协议 | TCP |
| HTTP | 超文本传输协议 | TCP | 
| HTTPS | 加密超文本传输协议 | TCP | 
| NFS | 网络文件系统 | UDP |
| DNS | 域名解析协议 | UDP | 
| SNMP | 简单网络管理协议 | UDP |
| TFTP | 通用文件传输协议 | UDP |

### 传输层的TCP和UDP


| 对比项 |     TCP      |          UDP       |
|-------|--------------|--------------------|
| 英文名称 | Transmission Control Protocol | User Datagram Protocol |
| 中文名称 | 传输控制协议 | 用户数据报协议 |
| 所在的网络层次 | 传输层 | 传输层 |
| 是否连接 | 面相连接  | 无连接 |
| 是否可靠 | 	可靠传输，使用流量控制和拥塞控制	| 不可靠传输，可能丢包，不使用流量控制和拥塞控制 |
| 连接对象个数 | 只能是一对一通信 | 支持一对一、一对多、多对一和多对多交互通信	 | 
| 传输方式	| 	**面向字节流** | **面向报文** | 
| 首部开销	| 首部最小 20 字节，最大 60 字节 | 首部开销小，仅 8 字节	 |
| 数据顺序性 | 保证 | 不保证 | 
| 适用场景	| 适用于要求可靠传输的应用，例如文件传输 | 适用于实时应用（IP电话、视频会议、直播等） |

* TCP 向上层提供面向连接的可靠服务 ，UDP 向上层提供无连接不可靠服务。
* 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为。
* 对数据准确性要求高，速度可以相对较慢的，可以选用 TCP。
* TCP 建立连接需要三次握手，断开连接需要四次握手（TCP 是双向连接）。


### TCP的拥塞控制

* ref 1-[TCP拥塞控制算法 | Segmentfault](https://segmentfault.com/a/1190000040194435)


TCP 拥塞控制有 4 种算法
1. 慢开始
2. 拥塞避免
3. 快重传
4. 快恢复



### TCP如何保证可靠性、

1. 序列号和确认号机制
   * TCP 发送端发送数据包的时候会选择一个 seq 序列号，接收端收到数据包后会检测数据包的完整性，如果检测通过会响应一个 ack 确认号表示收到了数据包。
2. 超时重发机制
   * TCP 发送端发送了数据包后会启动一个定时器，如果一定时间没有收到接受端的确认后，将会重新送该数据包。
3. 对乱序数据包重新排序
   * 从 IP 网络层传输到 TCP 层的数据包可能会乱序，TCP 层会对数据包重新排序再发给应用层。
4. 丢弃重复数据
   * 从 IP 网络层传输到 TCP 层的数据包可能会重复，TCP 层会丢弃重复的数据包。
5. 流量控制
   * TCP 发送端和接收端都有一个固定大小的缓冲空间，为了防止发送端发送数据的速度太快导致接收端缓冲区溢出，发送端只能发送接收端可以接纳的数据，为了达到这种控制效果，TCP 用了流量控制协议（可变大小的滑动窗口协议）来实现。

### TCP和UDP的首部

* [TCP首部和UDP首部 | Segmentfault](https://segmentfault.com/a/1190000021520661)
* [TCP报文段首部格式详解 | CSDN](https://blog.csdn.net/wilsonpeng3/article/details/12869233)


TCP 首部报文格式如下图。

![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/tcp-head-data-1.png)


UDP 首部报文格式如下图。

![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2020/udp-head-data-1.png)

### 网络层的HTTP

HTTP 指的是 `Hyper Text Transfer Protocol`（超文本传输协议），是应用层协议，TCP 是传输层协议。HTTP 是建立在 TCP/IP 协议之上的，基于 TCP/IP 通信协议来传递数据。

TCP 协议是传输层的协议，是以二进制数据流的形式传输数据，对上层的应用开发不太有好，所以产生了 HTTP 协议。HTTP 是应用层协议，主要解决如何包装数据（文本信息），是建立在 TCP 协议之上的应用层的协议。


> **注意，网络请求中，建立连接的三次握手，是 TCP 的的三次握手，不是 HTTP 的三次握手。**


#### HTTP的特点



1. HTTP 是无连接的
   * 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。
2. HTTP 是媒体独立的
   * 这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过 HTTP 发送。
3. HTTP 是无状态的
   * HTTP 协议是无状态协议。
   * 无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传。
   * 可以使用 cookie 保存会话信息


#### HTTP的版本
* ref 1-[HTTP 0.9、1.0、1.1、2.0、3.0](https://www.cnblogs.com/FdWzy/p/12567822.html)



> HTTP 1.0
1. HTTP 1.0 版本的缺点是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（`slow start`）。所以，HTTP 1.0 版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。


> HTTP 1.1

1. 引入了持久连接（`persistent connection`），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 `Connection: keep-alive`。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`，明确要求服务器关闭 TCP 连接。
2. 引入了管道机制（`pipelining`），即在同一个 TCP 连接里面，客户端可以同时发送多个请求。这样就进一步改进了 HTTP 协议的效率。举例来说，客户端需要请求两个资源，以前的做法是在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。
3. 采用分块传输编码，对于一些很耗时的动态操作，服务器需要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用 “流模式（stream）” 取代 “缓存模式（buffer）”。
4. 虽然 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为 “队头堵塞（Head-of-line blocking）”。为了避免这个问题，只有两种方法，一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入 CSS 代码、域名分片（domain sharding）等等。如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。



> HTTP 2.0
1. 二进制传输。HTTP 1.x 中采用的是基于文本的方式传输数据。采用二进制传输，实现更加方便且健壮。
2. HTTP 2.0 中，有两个概念非常重要，帧（frame）和流（stream）。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。
3. 多路复用。在一个 TCP 连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免 HTTP 旧版本的队头阻塞问题，极大提高传输性能。
4. Header 压缩。使用了 HPACK（HTTP 2 头部压缩算法）压缩格式对传输的 header 进行编码，减少了 header 的大小。


> HTTP 3.0
1. 谷歌开发的 QUIC 协议，利用 UDP 实现可靠数据传输。








### socket和websocket


> **Socket 不属于某种协议，只是网络编程技术。**



* **Socket（套接字） 是 TCP/IP 网络的 API，是为了方便使用 TCP 或 UDP 而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。**



![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/socket-tcp-1.png)


* **Socket 是 TCP/IP 网络的 API ，其实就是一个「门面模式」，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。**


* WebSocket 是一个典型的应用层协议（同 HTTP 一样，但它是一种双向通信协议），是建立在 TCP 之上的。


#### WebSocket与HTTP
相同点
1. 都是一样基于 TCP 的，都是可靠性传输协议。
2. 都是应用层协议。

不同点
1. WebSocket 是双向通信（全双工）协议，模拟 Socket 协议，可以双向发送或接受信息。HTTP 是单向（半双工）的。
2. WebSocket 是需要握手进行建立连接的。
3. HTTP 是基于文本传输，WebSocket 是基于二进制协议。





## HTTP

### 4种请求方法

HTTP 有 4 种请求方法
1. GET（查看）
2. PUT（更新）
3. POST（创建）
4. DELETE（删除）


### GET 和 POST 的区别


#### 精简版

1. 用途
   * get 请求用来从服务器获取资源；
   * post 请求用来向服务器提交数据；
2. 表单的提交方式
   * get 请求直接将表单数据以 `name1=value1&name2=value2` 的形式拼接到 URL 上，多个参数参数值需要用 `&` 连接起来并且用 `?` 拼接到 action 后面；
   * post 请求将表单数据放到请求头（header）或者请求的消息体中；
3. 传输数据的大小限制
   * get 请求传输的数据受到 URL 长度的限制，而 URL 长度是由浏览器决定的；
   * post 请求传输数据的大小理论上来说是没有限制的；
4. 参数的编码
   * get 请求的参数会在地址栏明文显示，使用 URL 编码的文本格式传递参数；
   * post 请求使用二进制数据多重编码传递参数；
5. 缓存
   * get 请求可以被浏览器缓存被收藏为标签；
   * post 请求不会被缓存也不能被收藏为标签；

#### 完整版


参考 [总结GET与POST区别 | 掘金](https://juejin.cn/post/7001782277063573518)，二者区别如下。

本质上，GET 和 POST 都是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致它们在应用过程中会体现出一些区别。区别主要体现在
* GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
* GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。
* GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
* GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
* GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。
* GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。
* 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。
* GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。POST 比 GET 安全，因为数据在地址栏上不可见。
* GET 参数通过 URL 传递，POST 放在 Request body 中。
* GET 请求长度最多 1024 kb，POST 对请求数据没有限制。HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。


| 比较项 |	GET	 |    POST   |
|------|---------|------------|
| 后退按钮/刷新	| 无害	| 数据会被重新提交（浏览器应该告知用户数据会被重新提交）|
| 书签	| 可收藏为书签	 | 不可收藏为书签 |
| 缓存	| 能被缓存	| 不能缓存 |
| 编码类型	| application/x-www-form-urlencoded	| application/x-www-form-urlencoded or multipart/form-data |
| 历史	| 参数保留在浏览器历史中 |	参数不会保存在浏览器历史中 |
| 对数据长度的限制	| 有限制，当发送数据时，GET 方法向 URL 添加数据，URL 的长度是受限制的，URL 的最大长度是 2048 个字符 |	无限制 |
| 对数据类型的限制	| 只允许 ASCII 字符 |	没有限制，也允许二进制数据 |
| 安全性	| 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分，在发送密码或其他敏感信息时绝不要使用 GET	| POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中 |
| 可见性	| 数据在 URL 中对所有人都是可见的 |	数据不会显示在 URL 中 |



### HTTP状态码

* [HTTP 状态码](https://www.runoob.com/http/http-status-codes.html)


|  分类 |    分类描述    |
|-----|-----------------| 
| 1**	| 信息，服务器收到请求，需要请求者继续执行操作 |
| 2**	| 成功，操作被成功接收并处理 |
| 3**	 | 重定向，需要进一步的操作以完成请求 |
| 4**	| 客户端错误，请求包含语法错误或无法完成请求 |
| 5**	| 服务器错误，服务器在处理请求的过程中发生了错误 |


常用的状态码如下

|  状态码  |    状态英文名称   |   说明     |
|-----|-----------------|---------------|
| 200 | OK |请求成功，一般用于 GET 与 POST 请求 |
| 403	| Forbidden	| 服务器理解请求客户端的请求，但是拒绝执行此请求 |
| 404	| Not Found	| 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面 | 
| 502	| Bad Gateway	| 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503	| Service Unavailable | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 |
| 504	| Gateway Time-out |	充当网关或代理的服务器，未及时从远端服务器获取请求 |



### HTTP的长连接和短连接


HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。

> 短连接
1. 在 HTTP/1.0 中默认使用短链接，也就是说，浏览器和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。
2. 如果客户端访问的某个 HTML 或其他类型的 Web 资源，如 JavaScript 文件、图像文件、CSS 文件等。当浏览器每遇到这样一个 Web 资源，就会建立一个 HTTP 会话。

> 长连接
1. 从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。
2. 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭。如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
3. Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。



## HTTPS
* HTTP（`HyperText Transfer Protocol`) 是超文本传输协议。
* HTTPS（`Hypertext Transfer Protocol Secure`）是超文本传输安全协议，是一种透过计算机网络进行安全通信的传输协议。
* HTTPS 经由 HTTP 进行通信，但利用 `SSL/TLS` （SSL 指的是 Secure Socket Layer，安全套接层）来加密数据包。HTTPS 开发的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。


### HTTPS的工作流程

![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2023/https-step-by-step-1.png)


HTTPS 的工作流程如上图所示，具体步骤如下
1. 客户端发起 Https 请求，连接到服务器的 443 端口。
2. 服务器必须要有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。
3. 服务器将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。
4. 客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。
5. 客户端将公钥加密后的密钥发送到服务器。
6. 服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。
7. 服务器将加密后的密文返回到客户端。
8. 客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。





### HTTP与HTTPS区别

| 比较项 |        HTTP      |      HTTPS   |
|-------|------------------|---------------|
| 安全性 | 不安全 |  安全 |
| 默认端口号 | 80 | 443 |
| 资源消耗 | 较少 | 较多 |
| 是否需要证书 | 不需要 | 需要 |
| 报文是否加密 | 明文 | 密文 |


1. HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL + HTTP） 数据传输过程是加密的，安全性较好。
2. 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。
3. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包。而 HTTPS 除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
4. HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
5. HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，HTTPS 比 HTTP 要更耗费服务器资源。


## Cookie-Session-Token
* ref 1-[Cookie，Session和Token对比 | Segmentfault](https://segmentfault.com/a/1190000022054795)


### cookie和session



![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/cookie-session-id-1.png)

* 存储位置：cookie 是存储在客户端的，session 是存储在服务器端的。`sessionId` 会被存储在 cookie中，`sessionId` 是连接 cookie 和 session 的一道桥梁。
* 安全性：session 是存储在服务器端的，所以session 比 cookie 安全。
* 存取值的类型不同：cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串。session 可以存任意数据类型。
* 有效期不同：cookie 可设置为长时间保持，比如我们经常使用的默认登录功能。session 一般失效时间较短，客户端关闭（默认情况下）或者 session 超时都会失效。
* 存储大小不同：单个 cookie 保存的数据不能超过 4K。session 可存储数据远高于 cookie，但是当访问量过多，会占用过多的服务器资源。



### token

* token 是访问资源接口（API）时所需要的资源凭证
* token 的身份验证流程如下图所示。

![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/cookie-token-1.png)


session 和 token 对比而言
1. session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 token 是令牌，访问资源接口（API）时所需要的资源凭证，**token 使服务端无状态化，不会存储会话信息。**
2. 作为身份认证，token 安全性比 session 好。
3. JSON Web Token（简称 `JWT`）是目前最流行的跨域认证解决方案。




## 分布式Session
* ref 1-[分布式session的几种解决方案 | 阿里云](https://developer.aliyun.com/article/842002)
* ref 2-[分布式集群环境下Session共享的解决方案](https://blog.51cto.com/u_14622170/4977473)



Session 的内容是存储在服务器端的，客户端通过 seesionId 和服务端进行交流。在单机环境下，服务端获取到客户端传来的 sessionId 并查找对应的 session 内容。若对应的 session 不存在，则创建一个新的 session。

如果采用分布式集群环境，如何做到session环境呢？有如下 4 种解决方案
1. 客户端存储 session
2. session 复制
3. session 黏性
4. session 持久化
5. session 共享（redis、spring-session）


### 客户端存储 session

直接将 session 信息存储在客户端，存储到客户端的 cookie 中。这样做虽然可以解决问题，但存在如下问题这
* 安全性存在问题
* cookie 对于数据类型（只支持存字符串数据）及数据大小（4kb）有所限制


### session 复制

将服务器 A 的 session，复制到服务器 B；同样将服务器 B 的 session 也复制到服务器 A。这样两台服务器的 session 就一致了。

像 Tomcat 等 web 容器都支持 session 复制的功能，在同一个局域网内，一台服务器的 session 会广播给其他服务器。

该方案的缺点是
* 同一个网段内服务器太多，每个服务器都会去复制 session，会造成服务器内存浪费。


### session 粘性

利用 Nginx 服务器的反向代理，采用 `ip_hash` 的负载均衡策略，将客户端和服务器进行绑定，Ngnix 每次都将同一用户的所有请求转发至同一台服务器上。

该方案的缺点是
* 如果某台服务器宕机了，则该服务器对应的 session 会丢失


### session 持久化
将 session 存储至数据库中，像操作数据一样操作 session。


### session 共享（redis、spring-session）

将所有服务器的 session 统一管理，可以使用 redis，memcache 等缓存系统存储 session，系统设计如下图所示。


![distributed-session-redis-1](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/distributed-session-redis-1.png)


Spring 官方提供的 `spirng-session` 也是这样处理 session 一致性问题的，也是目前业内主流的解决方案。


Spring Session 提供了对 redis，mongodb，mysql 等常用的存储库的支持。Spring Session 提供与 HttpSession 的透明整合，这意味着开发人员可以使用Spring Session 支持的实现切换 HttpSession 实现。

* Spring Session 相关依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```