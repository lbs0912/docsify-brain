
# 技术杂谈-01-4种序列化方式



[TOC]


## 更新
* 2022/03/15，撰写


## 参考资料
* [序列化理解起来很简单 | 知乎](https://zhuanlan.zhihu.com/p/40462507)
* [msgpack.org](http://msgpack.org/)
* [hessian doc](http://hessian.caucho.com/doc/hessian-serialization.html)
* [两种数据序列化方案性能对比：Msgpack和Json](https://ask.zkbhj.com/?/article/258)
* [类继承导致 RPC 调用 msgpack 序列化问题分析](https://toutiao.io/posts/s9nhng/preview)
* [深入浅出序列化——JDK序列化和Hessian序列化](https://juejin.cn/post/6991473304011800590)
* [MsgPack和Hessian序列化的区别](https://juejin.cn/post/7064495591065124878)


## 前言

常用的序列化方式有如下 4 种
1. json
2. messagepack（msgpack），二进制协议，可读性较差
3. hession，二进制序列化，可读性较差
4. protobuf，二进制协议，可读性较差

此外还有
1. JDK（不支持跨语言）
2. FST（不支持跨语言）
3. thrift


## 什么是序列化

1. 序列化：把对象转化为「可传输的字节序列」过程称为序列化。
2. 反序列化：把「字节序列」还原为对象的过程称为反序列化。



## 为什么要序列化


**其实序列化最终的目的是为了对象可以「跨平台存储」，和「进行网络传输」。而我们进行「跨平台存储」和「网络传输」的方式就是 IO，而我们的 IO 支持的数据格式就是「字节数组」。**

因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从 IO 流里面读出数据的时候，再以这种规则把对象还原回来（反序列化）。


## 什么情况下需要序列化

通过上面我想你已经知道了，凡是需要进行「跨平台存储」和「网络传输」的数据，都需要进行序列化。

本质上，「存储」和「网络传输」都需要经过「把一个对象状态保存成一种跨平台识别的字节格式」的处理，然后其他的平台才可以通过字节信息解析还原对象信息。



## 序列化技术选型的几个关键点

序列化协议各有千秋，不能简单的说一种序列化协议是最好的，只能从你的当时环境下去选择最适合你们的序列化协议，如果你要为你的公司项目进行序列化技术的选型，那么主要从以下几个因素。

1. 协议是否支持跨平台
   * 如果你们公司有好多种语言进行混合开发，那么就肯定不适合用有语言局限性的序列化协议，要不然你 JDK 序列化出来的格式，其他语言并没法支持。
2. 序列化的速度
   * 如果序列化的频率非常高，那么选择序列化速度快的协议会为你的系统性能提升不少。
3. 序列化出来的大小
   * 如果频繁的在网络中传输的数据那就需要数据越小越好，小的数据传输快，也不占带宽，也能整体提升系统的性能。


## Java 如何实现序列化

Java 实现序列化很简单，只需要实现 Serializable 接口即可。

## Java 序列化中常见的问题

### static 属性不能被序列化

序列化保存的是对象的状态，静态变量属于类的状态，因此，序列化并不保存静态变量。


### transient 属性不会被序列化

本章节参加笔记「 Java-20-Effective Java」中「transient」部分。

### 序列化版本号serialVersionUID

所有实现序列化的对象都必须要有个版本号，这个版本号可以由我们自己定义，当我们没定义的时候，JDK 工具会按照我们对象的属性生成一个对应的版本号。


> 版本号有什么用

主要用于提示用户这个类是否有更新。我们的对象通常需要根据业务的需求变化要新增、修改或者删除一些属性，在我们做了一些修改后，就通过修改版本号告诉 反序列化的那一方，对象有了修改你需要同步修改。

> 使用 JDK 生成的版本号和我们自定义的版本号的区别

JDK 工具生成的 serialVersionUID 是根据对象的属性信息生成的一个编号，这就意味着只要对象的属性有一点变动，那么它的序列化版本号就会同步进行改变。

这种情况有时候就不太友好，就像我们的软件一样，使用 JDK 生成的serialVersionUID，只要对象有一丁点改变，serialVersionUID 就会随着变更，这样的话用户就得强制更新软件的版本，用户不更新就使用不了软件。

而大多数友好的情况也许是这样的，用户可以选择不更新，不更新的话用户只是无法体验新加的功能而已。

而这种方式就需要我们自定义的版本号了，这样我就可以在新增了属性后不修改serialVersionUID，反序列化的时候只是无法获取新加的属性，并不影响程序运行。

所以，总结而言，有如下结论
1. 使用 JDK 工具生成的 serialVersionUID 时，若对象的字段发生了变化，会生成一个新的 serialVersionUID。这样调用方若不更新 serialVersionUID，会导致反序列化失败。
2. 使用自定义 serialVersionUID，对象的字段发生了变化，serialVersionUID 可以保持不变。此情况下，反序列化的时候只是无法获取新加的属性，并不影响程序运行。

## msgpack


MessagePack 是一个高效的二进制序列化格式。它让你像 JSON 一样可以在各种语言之间交换数据，但是它比 JSON 更快、更小。因为 msgpack 是一个二进制格式，所以没法像 JSON 后的字符串一样可直观地查看数据。

> It's like JSON,but fast and small. 

![msgpack-json-speed-1](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/msgpack-json-speed-1.png)


### msgpack字段兼容规则

对一个 bean 对象，msgpack 是按照 bean 对象中属性的顺序进行序列化和反序列化的。

所以在 RPC 服务中，若采用了 msgpack 序列化方式，在修改 bean 对象时，需要注意如下字段兼容规则
1. 不能调整原有字段顺序，不能删减字段，除非是删最后一个字段
2. 新加的字段必须在字段最后面（只是字段顺序，不是文件最后面，getter/setter 方法等随意）
3. 父类的字段不能变，因为父类一变相当于子类的中间插入一个字段


> 满足上面规则，服务端和客户端任一方修改，不会对另一方造成影响。如果是需要父类加字段，或者中间加减字段这种，则需要服务端和调用端同时修改。






## Hession


* ref 1-[五句话介绍Hessian序列化](https://cloud.tencent.com/developer/article/1706130)

> Hessian is a dynamically-typed, binary serialization and Web Services protocol designed for object-oriented transmission. 

Hessian 是一种动态类型、二进制序列化和 Web 服务协议，专为面向对象的传输而设计。


**需要注意的是，使用 hession 序列化方式时，父类和子类不能拥有同名的成员变量，否则会存在值覆盖的问题。**

Hessian 会把复杂的对象所有属性存储在一个 Map 中进行序列化。所以在父类、子类中存在同名成员变量的情况下，hessian 序列化时，先序列化子类，然后序列化父类。因此，反序列化结果会导致子类同名成员变量被父类的值覆盖。

**Hession 协议简单，比 Java 原生序列化高效。相比Hessian 1，Hessian 2 中增加了压缩编码，其序列化二进制流大小是 Java 序列化的 50%，序列化耗时是 Java 序列化的 30%，反序列化耗时是 Java 序列化的 20%。**



## msgpack对比hessian
* Hessian 序列化的时候，会写入字段名称，然后字段值，可以想象为一个 map。
* MsgPack 序列化的时候，不写入字段名字，会按字段顺序写入值，可以想象为一个数组。
* **因此，Hessian 序列化产生的数据包较大，Msgpack 序列化产生的数据包较小。Msgpack 比 Hession 的序列化性能也更好，压缩比也更高。**

![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/msgpack-hession-1.png)

* hessian 的扩展性更好，上下兼容时可以随意添加字段位置（相当于 map 可以随便赋值）
* msgpack 的性能更佳，上下兼容时，需要保证字段顺序（包括枚举顺序）



## protobuf

Protobuf (Protocol Buffers) 是谷歌开发的一款无关平台，无关语言，可扩展，轻量级高效的序列化结构的数据格式，用于将自定义数据结构序列化成字节流，和将字节流反序列化为数据结构。


**因为 Protobuf 是二进制数据格式，需要编码和解码。数据本身不具有可读性，因此只能反序列化得到可读数据。**

相对于其他数据格式，Protobuf 的优势
1. 序列化后体积比 JSON 和 XML 小，适合网络传输
2. 序列化反序列化速度快，比 JSON 的处理速度快
3. 消息格式升级和兼容性还不错


Protobuf 的缺点是
1. 二进制格式，可读性差（抓包 dump 后的数据很难看懂）
2. 对象冗余，字段很多，生成的类较大，占用空间
3. 默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）