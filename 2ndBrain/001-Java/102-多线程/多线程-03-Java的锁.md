# 多线程-03-Java的锁


[TOC]


## 更新
* 2022/04/20，撰写
* 2022/05/15，添加 *死锁*

## 什么是锁

* [锁（计算机） | 维基百科](https://zh.wikipedia.org/wiki/%E9%94%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))


在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。



使用 `synchronized` 修饰代码块，则在同一时间内，该代码块只能被单个线程访问。其背后原理就是向该代码块加了锁。

**一段 `synchronized` 的代码若要被一个线程执行，该线程必须先拿到执行这段代码的权限，在 Java 里边就是拿到这个同步对象的锁（一个对象只有一把锁）。**

> 如果同步对象的锁被其他线程拿走了，这个线程就只能等了，即该线程阻塞在锁池等待队列中。当该线程取到锁后，就开始执行同步代码（被 `synchronized` 修饰的代码），该线程执行完同步代码后马上就把锁还给同步对象。在锁池中等待的其他的某个线程就可以拿到这个锁执行同步代码了。这样就保证了同步代码在统一时刻只有一个线程在执行。


## Java的锁机制

Java 中的锁机制主要分为 `Lock` 和 `Synchronized`。



### Synchronized

`Synchronized` 是Java提供的一种排他的（独占锁），可重入的内置锁。



### Lock
JavaSE 5 之后，并发包中新增了 `Lock` 接口（以及相关实现类）用来实现锁功能，它提供了与 `synchronized` 关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种 `synchronized` 关键字所不具备的同步特性。


此处给出一个使用 Lock 的简单示例。


```java
Lock lock = new ReentrantLock();  
lock.lock();  
try {  
    // ..
} finally {
    lock.unlock();
}
```

需要注意的是
* 在 `finally` 块中释放锁，目的是保证在获取到锁之后，最终能够被释放
* 不要将获取锁的过程写在 `try` 块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，会提前进行 `unlock` 导致 `IllegalMonitorStateException` 异常



## 锁的分类

* [不可不说的Java锁事 | 美团技术](https://tech.meituan.com/2018/11/15/java-lock.html)
* [Java锁分类介绍 | 无涯教程](https://www.learnfk.com/java/java-concurrent-java-lock.html)


![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/java-lock-all-kinds-1.png)


![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/java-lock-all-kinds-2.png)


Java 中的锁有很多，可以按照不同的功能和种类进行分类
* 从线程是否需要对资源加锁，可以分为「悲观锁」和「乐观锁」
* 从资源已被锁定，线程是否阻塞，可以分为「互斥锁」和「自旋锁」（又细分出「适应性自旋锁」）
* 从多个线程并发访问资源，也就是 `Synchronized` 可以分为「无锁」、「偏向锁」、「轻量级锁」和「重量级锁」
* 从锁的公平性进行区分，可以分为「公平锁」和「非公平锁」
* 从根据锁是否重复获取可以分为「可重入锁」和「不可重入锁」
* 从多个线程能否获取同一把锁分为「共享锁」和「排他锁」




### 乐观锁和悲观锁

乐观锁和悲观锁并不是一种真实存在的锁，而是一种设计思想。

Java 中的 `Synchronized` 和 `ReentrantLock` 等独占锁(排他锁)都是一种悲观锁思想的实现。

乐观锁的实现方案一般来说有两种：版本号机制和CAS实现。

从 JDK1.5 开始支持，`java.util.concurrent` 包里提供了很多面向并发编程的类，也提供了 CAS 算法的支持，一些以 Atomic 为开头的一些原子类都使用 CAS 作为其实现方式，如原子类中的递增操作。


#### CAS算法
CAS（Compare-and-Swa)，即比较并替换算法，是一种无锁算法，即在不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（`Non-blocking Synchronization`）。

CAS 中涉及三个要素
* 需要读写的内存值 V
* 进行比较的值 A
* 拟写入的新值 B
  
当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。

CAS 虽然很高效，但是它也存在 3大问题
1. ABA问题
2. 循环时间长开销大
3. 只能保证一个共享变量的原子操作


### 互斥锁和自旋锁


对于一个共享资源 ，当已经有一个线程加锁后，其他线程再加锁就会失败
* 互斥锁加锁失败后，线程会释放 CPU，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程
* 自旋锁加锁失败后，会循环等待该资源是否已经释放锁。自旋锁减少了线程上下文切换的消耗。



#### 互斥锁的线程切换开销

互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。那这个开销成本是什么呢？会有两次线程上下文切换的成本
1. 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行
2. 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。


更进一步思考，线程的上下文切换的是什么？当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。

> 上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。—— [互斥锁和自旋锁的使用场景](https://cloud.tencent.com/developer/news/695304)

所以，如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。


#### 适应性自旋锁

自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用 `-XX:PreBlockSpin` 来更改）没有成功获得锁，就应当挂起线程。

> 自旋锁在 JDK1.4.2 中引入，使用 `-XX:+UseSpinning` 来开启。JDK 6 中变为默认开启。

自旋锁无法保证多线程竞争的公平性，当多个线程想要获取时，很容易出现某些线程一直都无法获取到锁造成「线程饥饿」。因此，在JDK 6 中引入了自适应的自旋锁（适应性自旋锁）。


自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。


适应性自旋锁中，常见的3种锁形式
1. TicketLock
2. CLHlock
3. MCSlock


### 无锁、偏向锁、轻量级锁和重量级锁


`synchronized` 通过 Monitor 来实现线程同步，Monitor 是依赖于底层的操作系统的 `Mutex Lock`（互斥锁）来实现的线程同步。这种依赖于操作系统 Mutex Lock所实现的锁我们称之为“重量级锁”。JDK 6 中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。


Java 语言专门针对 `synchronized` 关键字设置了四种状态（锁状态从低到高，锁状态只能升级不能降级）
* 无锁
* 偏向锁
* 轻量级锁
* 重量级锁
  
上面4种锁状态对应的Java对象头的 `Mark Word` 的内容如下。

| 锁状态  |           存储内容                 |  存储内容  |
|--------|-----------------------------------|-----------|
|  无锁   | 对象的hashCode、对象分代年龄、是否是偏向锁（0）|  01 |
| 偏向锁  | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） | 01 |
| 轻量级锁 |                   指向栈中锁记录的指针          |  00  |
| 重量级锁 |         指向互斥量（重量级锁）的指针              | 10   |


下面介绍下4种锁状态对应的特点。


#### 无锁

无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。上文中介绍的CAS算法就是无锁的实现。

#### 偏向锁

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。

#### 轻量级锁

当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。

#### 重量级锁

重量级锁是将除了拥有锁的线程以外的线程都阻塞。



### 公平锁和非公平锁
* ref 1-[公平锁和非公平锁有什么区别 | 掘金](https://juejin.cn/post/7095542612563607560)



公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入等待队列中排队（进入队尾并进入休眠状态），队列中的第一个线程才能获得锁。非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。使用非公平锁时，每个线程获取锁的顺序是随机的，并不会遵循先到先得的规则。

在 Java 中，锁 `synchronized` 和 `ReentrantLock` 默认都是非公平锁。在创建 `ReentrantLock` 时，通过 `new ReentrantLock(true)` 可以手动指定其为公平锁，但 `synchronized` 只能为非公平锁。

> Java 中的 `ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承 `AQS`（`AbstractQueuedSynchronizer`），添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的。它有公平锁 `FairSync` 和非公平锁 `NonfairSync` 两个子类。`ReentrantLock` 默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。



```java
    public ReentrantLock() {
        sync = new NonfairSync();
    }

    /**
     * Creates an instance of {@code ReentrantLock} with the
     * given fairness policy.
     *
     * @param fair {@code true} if this lock should use a fair ordering policy
     */
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
```

#### 执行流程分析

* 公平锁执行流程
  
多个线程按照申请锁的顺序来获取锁，线程直接进入等待队列中排队（进入队尾并进入休眠状态）。当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，锁的使用顺序也就是队列中的先后顺序。在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态。线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。

* 非公平锁执行流程

当线程获取锁时，会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。

* 下面给出一张《Java并发编程实战》中的「公平锁和非公平锁的性能测试」对比图。可以看出，使用非公平锁的吞吐率（单位时间内成功获取锁的平均速率）要比公平锁高很多。


![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/java-lock-fair-unfair-vs-1.png)


#### 优缺点分析
* 公平锁的优点是按申请锁的顺序分配锁资源，不会出现「线程饿死」的情况。缺点是按序唤醒线程的开销大，执行性能不高。 
* 非公平锁的优点是执行效率高，谁先获取到锁，锁就属于谁，并不会遵循先到先得的规则。缺点是资源分配随机性强，可能会出现「线程饿死」的情况。
* 使用非公平锁的吞吐率（单位时间内成功获取锁的平均速率）要比公平锁高很多。

* 公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大。




### 可重入锁和非可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java 中 `ReentrantLock` 和 `synchronized` 都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。

```java
public class Widget {
    public synchronized void doSomething() {
        System.out.println("方法1执行...");
        doOthers();
    }

    public synchronized void doOthers() {
        System.out.println("方法2执行...");
    }
}
```

如上代码，类中的两个方法都是被内置锁 `synchronized` 修饰的，`doSomething()` 方法中调用 `doOthers()` 方法。因为内置锁是可重入的，所以同一个线程在调用`doOthers()` 时可以直接获得当前对象的锁，进入 `doOthers()` 进行操作。

如果是一个不可重入锁，那么当前线程在调用 `doOthers()` 之前需要将执行 `doSomething()` 时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。




### 独享锁和共享锁

独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程 T 对数据 A 加上排它锁后，则其他线程不能再对 A 加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK 中的 `synchronized` 和 JUC 中 `Lock` 的实现类就是互斥锁。

共享锁是指该锁可被多个线程所持有。如果线程 T 对数据 A 加上共享锁后，则其他线程只能对 A 再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。


Java 中的 `ReentrantReadWriteLock` 有两把锁，`ReadLock` 和 `WriteLock`。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以 ReentrantReadWriteLock 的并发性相比一般的互斥锁有了很大提升。



## 死锁
* ref 1-[死锁产生的原因 | 掘金](https://juejin.cn/post/7096286940340682765)


### 什么是死锁

死锁（Dead Lock）指的是两个或两个以上的运算单元（进程、线程或协程），都在等待对方释放资源，但没有一方提起释放资源，从而造成了一种阻塞的现象。


### 产生死锁的4个条件

产生死锁，需要满足下面4个条件
1. 互斥条件
指运算单元（进程、线程或协程）对所分配到的资源具有排它性，也就是说在一段时间内某个锁资源只能被一个运算单元所占用。

2. 请求和保持条件
指运算单元已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它运算单元占有，此时请求运算单元阻塞，但又对自己已获得的其它资源保持不放。

3. 不可剥夺条件
指运算单元已获得的资源，在未使用完之前，不能被剥夺。

4. 环路等待条件
指在发生死锁时，必然存在运算单元和资源的环形链，即运算单元正在等待另一个运算单元占用的资源，而对方又在等待自己占用的资源，从而造成环路等待的情况。



### 如何避免死锁

1. 从产生死锁的4个条件出发，只要至少打破4个条件中的任意一个即可。
2. 尽量保证加锁顺序是一样的（打破互斥条件）
    * 例如，有A、B、C三把锁，线程 Thread-1 的加锁顺序为A、B、C
    * 若线程 Thread-2 的加锁顺序为 A、C，此时不会发生死锁
    * 若线程 Thread-2 的加锁顺序为 B、A 或 C、A，此时会产生死锁
3. 尽量使用超时放弃机制（打破不可剥夺条件）
