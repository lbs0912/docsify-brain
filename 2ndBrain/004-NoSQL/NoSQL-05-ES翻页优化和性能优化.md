
# NoSQL-05-ES翻页优化和性能优化


[TOC]

## 更新
* 2020/08/08，撰写


## 参考资料
* [Elasticsearch深度分页解决方案 | CSDN](https://blog.csdn.net/weixin_36380516/article/details/120858001)
* [ES查询性能调优实践 - 亿级数据查询毫秒级返回](https://cloud.tencent.com/developer/article/1427848)





## 前言


在 Elasticsearch 使用的基础上，探讨「ES翻页优化」和「ES性能优化」。


## ES翻页


ES 翻页，有下面几种方案
1. `from` + `size` 翻页
2. `scroll` 翻页
3. `scroll scan` 翻页
4. `search after` 翻页






### from + size 翻页


```s
POST /my_index/my_type/_search
{
    "query": { "match_all": {}},
    "from": 100,
    "size":  10
}
```



使用 `from` + `size` 可进行翻页
* `from` 参数定义了需要跳过的 `hits` 数，默认 0
* `size` 参数定义了需要返回的 `hits` 数目的最大值


> ES 默认的单页查询最大限制（`max_result_window`）为10000。


该方案在翻页数目较多（即 `from` 较大）或者 `size` 特别大的情况，会出深翻页问题（`deep pagination`)。



该方案的优点
1. 实现较为简单
2. 可以指定任意合理的页码，实现跳页查询


该方案的缺点
1. 深翻页时，耗时较长




### `scroll` 翻页

* ref 1-[利用Scan和Scroll处理大结果集](https://www.bookstack.cn/read/Spring-Data-Elasticsearch/5-5.3-5.3.2.md)



`scroll` 翻页方案，主要用于「一次性查询大量的数据（甚至是全部数据）」，适合「非实时处理大量数据」的场景，该方案并不适合用来做「实时数据查询」。
1. 第一次查询时，会生成一个 `scrollId`，并将所有符合搜索条件的搜索结果缓存起来。注意，这里只是缓存的 `doc_id`，并不是真的缓存了所有的文档数据，取数据是在 `fetch` 阶段完成的。
2. 后续查询时，需要携带上一次查询返回的 `scrollId`。




`from` + `size` 翻页方案中，我们可以指定任意合理的页码，实现跳页查询；但在 `scroll` 方案中，无法实现跳页面查询，因为该方案中除了第一次查询，其余的查询都需要上一次查询返回的 `scrollId`。





该方案的优点
1. 性能较好，适合一次性查询大量的数据




该方案的缺点
1. 使用了 `scrollId`，会占用大量的资源（特别是排序的请求）
2. 生成的 `scrollId` 是基于历史数据的快照，若此时数据发生了变化，则不会反映在快照上，所以不适合用作「实时数据查询」



### `scroll scan` 翻页

`scroll scan` 方式在单纯 `scroll` 方式的基础上，进一步提升了性能，适合「非实时处理大量数据」的场景。

**单纯的使用 `scroll` 方式查询，可支持排序。若使用 `scroll` + `scan` 的方式，则不支持排序。** 


### `search after` 翻页


`Search after` 是 ES 5 引入的一种分页查询机制，其原理和 `scroll` 类似。
* 请求时，会返回一个包含 `sort` 排序值的数组
* 在下一次请求时，可以将包含 `sort` 排序值的数组用于请求入参，以便抓取下一页的数据


该方案的优点
1. 不需要维护 `scrollId`，不需要维护快照，因此可以避免消耗大量的资源




该方案的缺点
1. 至少需要指定一个唯一的不重复字段来排序
2. 不适用于大幅度跳页查询，或者全量导出




### 翻页方案对比


| 翻页方式	| 性能 |  优点	 | 缺点	   | 场景  |
|---------|-------|---------|--------|---------|
| `from` + `size` |	低	| 灵活性好，实现简单 | 深度分页问题	| 数据量比较小，能容忍深度分页问题 |
| `scroll` | 中 | 解决了深度分页问题	| 需要维护一个 `scrollId`（快照版本），无法反应数据的实时性；可排序，但无法跳页查询 | 查询海量数据 |
| `scroll scan` | 中 | 基于 `scroll` 方案，进一步提升了海量数据查询的性能	| 无法排序，其余缺点同 `scroll` | 查询海量数据 |
| `search after` | 高	| 性能最好，不存在深度分页问题，能够反映数据的实时变更 | 实现复杂，需要有一个全局唯一的字段。连续分页的实现会比较复杂，因为每一次查询都需要上次查询的结果 | 不适用于大幅度跳页查询，适用于海量数据的分页 | 





对上述几种翻页方案，查询不同数目的数据，耗时数据如下表。


| ES 翻页方式  | 1-10 | 49000-49010 | 99000-99010 |
|-------------|------|-------------|-------------|
| from + size | 8ms  |   30ms      |    117ms    |
| scroll      | 7ms  |   66ms      |    36ms     |
| search_after| 5ms  |   8ms       |    7ms      |





## 性能优化



对 ES 查询性能进行优化，有如下思路
1. 拆分索引
   * 尽量缩小搜索的数据集范围
   * 可按照数据源拆分，或按时间拆分
2. 字段拉平，减少嵌套层级
   * 比如若在 `extra_info` 字段中又嵌套了几个搜索字段，在性能优化时，可考虑将这几个搜索字段和 `extra_info` 字段拉平，减少嵌套层级
3. 减少模糊匹配
4. 使用过滤器上下文（`filter`）代替查询上下文（`query`）
   * `filter` 查询子句的性能优于 `query` 查询子句
   * `filter` 查询子句不需要计算相关性的分值，并且查询结果可以缓存
   * `query` 查询子句需要计算相关性的分值
5. 减少不必要的查询字段
   * 一个 ES 查询包括两个阶段，`query` 和 `fetch`。若查询字段较多，`fetch` 阶段会耗时很大 





下面进行必要的补充说明。



### 过滤器上下文（`filter`）代替查询上下文（`query`）

ES 中提供了「查询上下文（`query`）」和「过滤器上下文（`filter`）」

1. 查询上下文（`query`）
   * `query` 查询子句用于回答「这个文档与此子句相匹配的程度」，ES 会计算相关度并维护一个 `_score` 分值，分值越高就代表越相关越匹配
2. 过滤器上下文（`filter`）
   * `filter` 查询子句用于回答「这个文档是否匹配这个子句」，ES 只需要回答 “是” 或 “否”，不需要为过滤器子句计算相关性分数
   * `filter` 查询的结果可以缓存

**可以看到，`filter` 查询子句不需要计算相关性的分值，并且查询结果可以缓存。所以，在满足业务需求的前提下，尽可能地使用 `filter` 查询子句代替 `query` 查询子句。**


### 查询的两个阶段：query和fetch


在 ES 中，搜索一般包括两个阶段，`query` 和 `fetch` 阶段
1. `query` 阶段
   * 根据查询条件，确定要取哪些文档（`doc`），筛选出文档 ID（`doc_id`）
2. `fetch` 阶段
   * 根据 `query` 阶段返回的文档 ID（`doc_id`），取出具体的文档（`doc`）


在一次业务场景中，从 1000W 的底池数据中查询出 10W 结果，当查询较多字段信息（返回 20 个字段），耗时约 8s，其中 `query` 阶段耗时约 500ms；当减少查询字段（返回 5 个字段），耗时约 2s，其中 `query` 阶段耗时约 480ms。从中可以得出如下结论 
1. **一次 ES 查询中，若查询字段和信息较多，`fetch` 阶段的耗时，远大于 `query` 阶段的耗时。**
2. **一次 ES 查询中，若查询字段和信息较多，通过减少不必要的查询字段，可以显著缩短查询耗时。**

