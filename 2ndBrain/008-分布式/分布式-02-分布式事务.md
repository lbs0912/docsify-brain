# 分布式-02-分布式事务

[TOC]


## 更新
* 2022/06/06，撰写

@todo 受限于面试时间，此处仅做大纲记录，后续完善该文章


## 参考资料
* [分布式事务六种解决方案 | 知乎 敖丙](https://zhuanlan.zhihu.com/p/183753774)




##  前言

严格意义上的事务，应该具备原子性、一致性、隔离性和持久性，即 ACID。

「分布式事务」，顾名思义，就是要在分布式系统中实现事务，它其实是由多个本地事务组合而成。

对于分布式事务而言，几乎满足不了 ACID，其实对于单机事务而言大部分情况下也没有满足 ACID，不然怎么会有四种隔离级别呢？所以更别说分布在不同数据库或者不同应用上的分布式事务了。


分布式事务的实现方案，有以下几种
1. 2PC（两阶段提交）
2. 3PC（三阶段提交）
3. TCC （`Try-Confirm-Cancel`），即「补偿事务」
4. 本地消息表
5. 消息事务
6. 最大努力通知




## 2PC

2PC（`Two-phase commit protocol`），即二阶段提交，是一种**强一致性设计**。

2PC 引入一个事务协调者的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交两个阶段。



![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/distributed-transaction-2pc-1.png)


**2PC 是一种尽量保证强一致性的分布式事务，因此它是同步阻塞的，而同步阻塞就导致长久的资源锁定问题，总体而言效率低，并且存在单点故障问题，在极端条件下存在数据不一致的风险。**
* 2PC 中的第一阶段中，协调者会等待所有参与者响应才会进行下一步操作，当然第一阶段的协调者有超时机制，假设因为网络原因没有收到某参与者的响应或某参与者挂了，那么超时后就会判断事务失败，向所有参与者发送回滚命令。
* 但是，2PC 的第二阶段中，是没有超时机制的，若执行失败，只能不断重试。
* 此外，2PC 中协调者是一个单点，会存在单点故障问题。针对该问题，若协调者产生故障，2PC 提供了一种重新选举协调者的方案。但是，新选举出来的协调者，是不知道之前协调者和参与者的状态的。


## 3PC

> 从维基百科上看，3PC 的引入是为了解决提交阶段 2PC 协调者和某参与者都挂了之后，新选举的协调者不知道当前应该提交还是回滚的问题。

3PC 的出现是为了解决 2PC 的一些问题，相比于 2PC，3PC 在参与者中也引入了超时机制，并且新增了一个阶段使得参与者可以利用这一个阶段统一各自的状态。

3PC 包含了 3 个阶段
1. 准备阶段（CanCommit）
2. 预提交阶段（PreCommit）
3. 提交阶段（DoCommit）

![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/distributed-transaction-3pc-1.png)


看起来是把 2PC 的提交阶段变成了预提交阶段和提交阶段，但是 3PC 的准备阶段协调者只是询问参与者的自身状况，3PC 的预提交阶段和 2PC 的准备阶段完成的工作类似，预提交阶段的引入起到了一个统一状态的作用。

3PC 比 2PC 多引入一个阶段，也多一个交互，因此性能会差一些，而且绝大部分的情况下资源应该都是可用的，这样等于每次明知可用执行还得询问一次。


总结而言，3PC 相对于 2PC 做了一定的改进：引入了参与者超时机制，并且增加了预提交阶段，使得故障恢复之后协调者的决策复杂度降低，但整体的交互过程更长了，性能有所下降，并且还是会存在数据不一致问题。

2PC 和 3PC 都不能保证数据 100% 一致，因此一般都需要有定时扫描补偿机制。


## TCC

2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务。分布式事务不仅仅包括数据库的操作，还包括发送短信等，这时候 TCC 就派上用场了。

TCC 指的是 `Try-Confirm-Cancel`。
1. `Try` 指的是预留，即资源的预留和锁定，注意是预留。
2. `Confirm` 指的是确认操作，这一步其实就是真正的执行了。
3. `Cancel` 指的是撤销操作，可以理解为把预留阶段的动作撤销了。


TCC 模型还有个事务管理者的角色，用来记录 TCC 全局事务状态并提交或者回滚事务。TCC 的流程如下图所示。

![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/distributed-transaction-tcc-1.png)



可以看到，TCC 的流程还是很简单的，难点在于业务上的定义，对于每一个操作你都需要定义三个动作分别对应 `Try-Confirm-Cancel`。

因此，TCC 对业务的侵入较大和业务紧耦合，需要根据特定的场景和业务逻辑来设计相应的操作。还有一点要注意，撤销和确认操作的执行可能需要重试，因此还需要保证操作的幂等。

相对于 2PC、3PC ，TCC 适用的范围更大，但是开发量也更大，毕竟都在业务上实现，而且有时候你会发现这三个方法还真不好写。不过也因为是在业务上实现的，所以 TCC 可以跨数据库、跨不同的业务系统来实现事务。



## 本地消息表

「本地消息表」其实就是利用了各系统本地的事务来实现分布式事务。

本地消息表，顾名思义，就是会有一张存放本地消息的表。一般都是放在数据库中，然后在执行业务的时候 将业务的执行和将消息放入消息表中的操作放在同一个事务中，这样就能保证消息放入本地表中业务肯定是执行成功的。

然后再去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息状态可以直接改成已成功。

如果调用失败也没事，会有「后台任务」定时去读取本地消息表，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。

这时候有可能消息对应的操作不成功，因此也需要重试，重试就得保证对应服务的方法是「幂等」的，而且一般重试会有最大次数，超过最大次数可以记录下报警让人工处理。

可以看到本地消息表其实实现的是最终一致性，容忍了数据暂时不一致的情况。





## 消息事务

* [消息队列经典十连问](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247497847&idx=1&sn=29a32672b712e7dfadfa36c9902b2ec7&chksm=cf22275ef855ae484fb3f51a5726e9a4bc45222e8fbbd33631d177dc4b5619c36889ea178463&token=1077989845&lang=zh_CN#rd)


RocketMQ 就很好的支持了消息事务，让我们来看一下如何通过消息实现事务。

第一步先给 Broker 发送事务消息即半消息，「半消息」不是说一半消息，而是这个消息对消费者来说不可见，然后发送成功后发送方再执行本地事务。

再根据本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令。

并且 RocketMQ 的发送方会提供一个「反查事务状态接口」，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。

如果是 Commit 那么订阅方就能收到这条消息，然后再做对应的操作，做完了之后再消费这条消息即可。

如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。

可以看到通过 RocketMQ 还是比较容易实现的，RocketMQ 提供了事务消息的功能，我们只需要定义好事务反查接口即可。



![](https://image-bed-20181207-1257458714.cos.ap-shanghai.myqcloud.com/back-end-2022/distributed-transaction-mq-1.png)



可以看到消息事务实现的也是最终一致性。



## 最大努力通知

* [分布式事务处理方案大 PK | 掘金](https://juejin.cn/post/7111177859146170404)


发起通知方通过一定的机制，最大努力将业务处理结果通知到接收方。具体包括
1. 有一定的消息重试机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息进行重试。
2. 消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。


在前面的章节，介绍了本地消息表和消息事务，这两种方案也都属于可靠消息，它们和最大努力通知有什么区别呢？
1. 可靠消息一致性：消息发起方需要保证将消息发出去，并且将消息发到接收方，消息的可靠性关键由发起方来保证。
   * 就本地消息表来说，会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。
   * 事务消息也是一样，当半消息被 `commit` 了之后确实就是普通消息了，如果订阅者一直不消费或者消费不了则会一直重试，到最后进入「死信队列」。其实这也算最大努力。
2. 最大努力通知：消息发起方尽最大努力将业务处理结果通知给接收方，但是可能消息接收不到，此时需要接收方主动调用发起方的接口查询业务处理结果，此时消息的可靠性关键在接收方。


在具体的解决方案上，最大努力通知需要消息发起方提供接口，让被通知方能够通过接口查询业务处理结果。



所以，「最大努力通知」其实只是表明了一种「柔性事务」的思想：我已经尽力我最大的努力，想达成事务的最终一致了。


「最大努力通知」适用于对时间不敏感的业务，例如短信通知。


「最大努力通知」适用于业务通知类型，最常见的场景就是支付回调
1. 支付服务收到第三方服务支付成功通知后，先更新自己库中订单支付状态，然后同步通知订单服务支付成功。
2. 如果此次同步通知失败，会通过异步脚步不断重试地调用订单服务的接口。

最大努力通知更多是业务上的设计，在基础设施层，可以直接使用二阶段消息，或者事务消息、本地消息表等来实现。


## 总结

可以看出 2PC 和 3PC 是一种强一致性事务，不过还是有数据不一致，阻塞等风险，而且只能用在数据库层面。

而 TCC 是一种补偿性事务思想，适用的范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。

本地消息表、事务消息和最大努力通知其实都是最终一致性事务，因此适用于一些对时间不敏感的业务。

| 分布式事务实现方案 | 设计思想 | 应用场景 |  特点 |
|-----------------|--------|---------|-------|
| 2PC | 强一致性事务 | 用于数据库层面 | 2PC 会有阻塞风险，并且参与者无超时重试机制 |
| 3PC| 强一致性事务 | 用于数据库层面 | 3PC 比 2PC 多引入一个阶段，也多一个交互，因此性能会差一些 |
| TCC | 补偿性事务思想 | 适用的范围较广 | 对业务的侵入性较大 |
| 本地消息表| 最终一致性事务 | - | -|
| 事务消息| 最终一致性事务 | - | -|
| 最大努力通知| 最终一致性事务 | - | -|


## 其他


@todo 受限于面试时间，此处仅做大纲记录，后续完善该文章


* [分布式事务最经典的七种解决方案 | Segmentfault](https://segmentfault.com/a/1190000040321750)


### SAGA

Saga 的核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。

Saga 一旦到了 Cancel 阶段，那么 Cancel 在业务逻辑上是不允许失败了。如果因为网络或者其他临时故障，导致没有返回成功，那么 TM 会不断重试，直到 Cancel 返回成功。

Saga事务的特点
1. 并发度高，不用像 XA 事务那样长期锁定资源
2. 需要定义正常操作以及补偿操作，开发量比XA大
3. **一致性较弱，对于转账，可能发生 A 用户已扣款，最后转账又失败的情况**

### Seata和AT事务模式

阿里开源项目 Seata 中使用了 AT 事务模式，在蚂蚁金服也被称为 FMT。

AT 事务模式的优点是该事务模式使用方式，类似 XA 模式，业务无需编写各类补偿操作，回滚由框架自动完成。缺点也类似 XA，存在较长时间的锁，不满足高并发的场景。

从性能的角度看，AT 模式会比 XA 更高一些，但也带来了脏回滚这样的新问题。


### 数据库的X/A事务规范

* [XA事务与两阶段提交 | 《MySQL是怎样运行的》](https://juejin.cn/book/6844733769996304392/section/7075316824065196044)


一个名叫 X/Open 的组织提出了一个名为 XA 的规范。该规范找那个，提出了 2个角色
1. 事务协调器（Transaction Coordinator）或者资源管理器，即「大哥」
   * 一个全局事务由多个小的事务组成，事务协调器用来协调和管理各个小事务
2. 事务管理器（Transaction Manager），即「小弟」
   * 管理具体的一个小事务


XA 规范中指出，要提交一个全局事务，必须分为 2 步
1. Prepare 阶段
2. Commit阶段
